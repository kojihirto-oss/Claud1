VCG/VIBE 運用Runbook及び実装パッチに関する包括的調査報告書
1. エグゼクティブサマリー
本報告書は、VCG/VIBE Single Source of Truth (SSOT) エコシステムの運用における「混乱ゼロ化（Zero Confusion）」を達成し、強固な信頼性を担保するための包括的な運用設計書兼修正提案書である。
既存の設計文書（DESIGN_MASTER）および調査レポート（Part1〜Part3）の詳細な分析に基づき、開発者が直面する運用上の曖昧さを完全に排除することを目的としている。特に、ローカル環境（IDE/CLI）とリモート環境（GitHub/CI）の役割分担、ブランチ運用戦略、Verify Gateによる品質保証プロセス、そしてセキュリティコンプライアンスの遵守について、微に入り細を穿つレベルで規定する。
調査の結果、理論上の設計は堅牢であるものの、実運用段階における人間とAIの協調フロー（HumanGate）、証跡管理（Evidence Management）、および例外処理の手順において、解釈の揺らぎが生じる余地が確認された 1。本報告書では、これらの課題に対し、「一本道（Single Path）」と呼ばれる決定論的なワークフローを策定し、迷いの生じる余地をシステム的に排除する解決策を提示する。
さらに、Model Context Protocol (MCP) のセキュリティ要件として、OAuth 2.1およびPKCE（Proof Key for Code Exchange）の必須化など、最新の業界標準に基づいたセキュリティ強化策を統合し 2、持続可能かつ安全な運用基盤を確立するための具体的なパッチ案を提供する。
________________
2. 第1章：運用哲学と役割分担の再定義
「混乱ゼロ化」を実現するためには、すべての操作において「誰が」「どこで」「何を」すべきかが、直感的かつ強制力を持って定義されていなければならない。本章では、ローカル環境とリモート環境の役割を物理的かつ論理的に分離し、それぞれの責務を明確化する。
2.1 「混乱ゼロ化」のための基本原則
SSOT運用の混乱は、主に「ローカルでやるべきことをリモートでやろうとする」、あるいはその逆の行動から生じる。これを防ぐため、以下の3つの鉄則を運用哲学として掲げる。
1. ローカルは「創造と試行」の場である：
ローカル環境は、コードの記述、ドキュメントの作成、そして高速な検証（Fast Verify）を行うためのサンドボックスである。ここでは破壊的な変更や試行錯誤が許容されるが、その結果が検証を通過しない限り、外部へ出ることは許されない。
2. リモートは「統合と承認」の場である：
GitHub（リモート）は、個人の作業成果をチーム全体の資産として統合し、厳格な監査（Full Verify）と人間による承認（HumanGate）を経て、公式な記録として保存する場である。ここでは直接的な編集作業は原則禁止され、手続き的な正当性が最優先される。
3. 証跡（Evidence）は通貨である：
作業が完了したことを証明するのは、本人の申告ではなく、機械的に生成された証跡ファイルのみである。Verify Gateを通過した証跡を持たない変更（PR）は、通貨を持たずに買い物をするのと同様であり、システムによって拒絶される。
2.2 役割分担マトリクス（場所×作業×責任×証跡）
以下の表は、各環境における許容される操作と禁止事項、そして責任の所在を網羅的に定義したものである。このマトリクスは、運用における憲法として機能する。
場所 (Location)
	主体 (Actor)
	許可される作業 (Authorized Tasks)
	禁止される作業 (Prohibited Tasks)
	責任 (Responsibility)
	証跡 (Evidence)
	ローカル IDE


(VS Code)
	開発者


Claude Code
	・仕様書/ADRの起草


・コード実装・修正


・ローカルFast Verifyの実行


・競合解決（Push前）
	・mainブランチへの直接コミット


・sources/内の既存ファイル変更・削除


・証跡ファイルの改竄
	品質担保


文法エラーや論理矛盾がない状態でコミットすること
	一時的証跡


evidence/verify_reports/*.md


(Git管理対象)
	ローカル CLI


(PowerShell/Bash)
	開発者


自動化スクリプト
	・verify_repo.ps1の実行


・Git操作（checkout, commit, push）


・recent-3ポリシーに基づくログ整理
	・git push -f（共有ブランチに対して）


・pre-commitフックのバイパス


・未検証状態でのPush
	手順遵守


決められたコマンド順序を守ること
	実行ログ


コンソール出力


ローカルログファイル
	リモート GitHub


(Web UI)
	レビュアー


HumanGate
	・Pull Request (PR) のレビューと承認


・マージ実行（Squash/Merge Commit）


・リリースタグの作成


・インシデント管理 (Issue)
	・Web UI上でのコード直接編集（微細なTypo修正を除く）


・CI失敗状態でのマージ強制


・証跡なしPRの承認
	ガバナンス


変更がアーキテクチャ全体に整合しているかの判断
	監査証跡


PRコメント


Review Approvalログ
	CI / CD


(GitHub Actions)
	自動化Bot
	・Full Verifyの実行


・ソース完全性チェック


・セキュリティスキャン


・RAGキャッシュの更新
	・独自判断によるコード修正


・HumanGateを経ない自動マージ（重要ブランチ）
	客観的保証


環境非依存での動作保証
	永続的証跡


CI Build Logs


Artifacts
	MCP Server


(Local/Remote)
	AIエージェント
	・コンテキスト検索 (RAG)


・ツール実行（同意に基づく）
	・許可されたドメイン外へのデータ送信


・VAULT/への不正アクセス
	安全性


意図しない副作用の防止
	アクセスログ


MCP実行ログ
	2.2.1 領域間の「越境」に関する厳格なルール
このマトリクスにおいて最も重要な点は、「領域間の越境」に対する制約である。
   * ローカルからリモートへの越境:
ローカルでの作業結果をリモートに反映させる唯一の手段は git push であり、その前提条件としてローカルでの Fast Verify 通過と、コミットフックによる sources/ 保護チェックの通過が義務付けられる 5。
   * リモートからローカルへの越境:
リモートの状態をローカルに反映させる手段は git pull (または fetch + rebase) のみである。手動でのファイルコピーや、整合性の取れていないパッチ適用は禁止される。SSOTの原則に従い、正本は常にリモートの main ブランチにある。
________________
3. 第2章：ツール統合アーキテクチャと権限管理
AIツールやMCP（Model Context Protocol）を活用した運用において、ツールごとの権限範囲を明確にすることは、セキュリティとデータの整合性を守る上で不可欠である。ここでは、各ツールに割り当てられる「Permission Tier」と、MCPのセキュリティ実装について詳述する。
3.1 Permission Tierの詳細定義
ツールの能力や用途に応じて4つの階層（Tier）を設定し、各階層で許可される操作を制限する。これにより、強力なAIモデルが誤ってシステムを破壊するリスクを最小化する。
Tier 1: ReadOnly (分析・参照)
      * 対象ツール: Gemini CLI, Perplexity, MCP RAG Search
      * 許可される操作:
      * 外部ドキュメントの検索・参照。
      * 既存コードベースの構造解析。
      * docs/ ディレクトリの読み取り。
      * 制約:
      * ファイルシステムへの書き込み権限は一切持たない。
      * 出力は標準出力（stdout）または一時的なスクラッチパッドのみに限定される。
      * 目的:
      * 情報の収集とコンテキストの理解に特化し、現状維持（Non-invasive）を保証する。
Tier 2: PatchOnly (起草・軽微な修正)
      * 対象ツール: Z.ai Lite, GitHub Copilot (Autocomplete), AI Agents (Drafting Mode)
      * 許可される操作:
      * ログファイルの要約生成。
      * コミットメッセージの案出。
      * WORK/ ディレクトリまたは feat/ ブランチ内でのドラフト作成。
      * 既存ファイルに対する微細な修正（Typo修正、フォーマット整形）。
      * 制約:
      * SSOTのコア定義（docs/Part00など）の変更は禁止。
      * 変更は必ず人間によるレビューを前提とする。
      * 目的:
      * 定型作業の効率化と、本流に影響を与えない範囲での創造的支援。
Tier 3: ExecLimited (実装・検証)
      * 対象ツール: Claude Code (CLI), Local PowerShell Scripts
      * 許可される操作:
      * verify_repo.ps1 の実行。
      * Gitコマンドの実行（commit, push）。
      * コードのリファクタリングと実装。
      * 制約:
      * 破壊的コマンド（rm, git reset --hard 等）の実行には、HumanGate（人間による明示的な確認入力）を必須とする。
      * pre-commit フックによる制約を遵守し、sources/ への変更を検知した場合は操作を中断する。
      * 目的:
      * 実質的な開発作業の主体となり、高い権限を持つ一方で、機械的な安全装置による制御を受ける。
Tier 4: Admin (ガバナンス・リリース)
      * 対象ツール: Human Reviewers (開発者), Release Managers, GitHub Actions (with Secrets)
      * 許可される操作:
      * main ブランチへのマージ。
      * VAULT/ 内の機密情報管理。
      * 本番環境へのデプロイ承認。
      * Branch Protection Rules の設定変更。
      * 制約:
      * 多要素認証（MFA）による保護が必須。
      * 全ての操作は監査ログに記録される。
      * 目的:
      * システムの最終的な整合性とセキュリティを担保する最高権限。
3.2 MCPセキュリティ要件と実装 (OAuth 2.1 & PKCE)
MCPを用いたAIエージェントと外部ツールの連携において、セキュリティは最優先事項である。調査レポート 2 に基づき、以下のセキュリティ標準を強制する。
3.2.1 OAuth 2.1 の採用
従来のOAuth 2.0で指摘されていた脆弱性（Implicit Flowの利用など）を排除するため、OAuth 2.1 への準拠を必須とする。
      * Implicit Flowの廃止: アクセストークンをURLフラグメント経由で渡す方法は禁止する。常にAuthorization Code Flowを使用する。
      * PKCE (Proof Key for Code Exchange) の義務化: パブリッククライアント（CLIツールやローカルアプリ）だけでなく、コンフィデンシャルクライアントにおいてもPKCEの実装を必須とする 2。これにより、認可コード横取り攻撃を防ぐ。
3.2.2 トークン管理と保存
      * 保存場所: アクセストークンやリフレッシュトークンを、プレーンテキストファイル（例: .env や config.json）に保存することを禁止する。OSレベルのセキュアなストレージ（Windows Credential Manager, macOS Keychain, Linux Secret Service API）を使用しなければならない。
      * 有効期限とローテーション: アクセストークンは短命（Short-lived）に設定し、リフレッシュトークンのローテーションを実装することで、トークン漏洩時の被害を最小限に抑える 4。
3.2.3 ユーザー同意 (User Consent) とツール実行制御
MCPサーバーは、ツール実行要求を受け取った際、以下のフローに従ってユーザーの同意を確認しなければならない 8。
      1. 要求受信: クライアントから tools/call リクエストを受信。
      2. リスク評価: 要求された操作のリスクレベル（例: 読み取りのみ vs 書き込みあり）を判定。
      3. 同意確認:
      * 高リスク: ユーザーに対し、操作内容、対象リソース、リスクを明示し、明示的な承認（Yes/No）を求める。
      * 低リスク: 事前にホワイトリスト化された操作であれば、自動承認可能とする（ただしログは残す）。
      4. 実行: 同意が得られた場合のみツールを実行する。
________________
4. 第3章：Git/GitHub運用設計とブランチ戦略
「P0-2: main/integrate/featの役割不明」1 という混乱ポイントを解消するため、3層構造のブランチ戦略と、それを支えるGitHubの保護設定を定義する。
4.1 3層ブランチ戦略の理論と実践
Git運用における混乱の多くは、ブランチの「寿命」と「役割」の不一致から生じる。以下の3層モデルにより、コードの流れを一方向に整流する。
Layer 1: Feature Branch (feat/***, fix/***)
      * 役割: 個別のタスクを実行するための作業用ブランチ。
      * 寿命: 短期（数時間〜数日）。マージ後は即座に削除される。
      * 作成元: 常に最新の origin/main から作成する。
      * 命名規則: feat/<TICKET-ID>-<description> または fix/..., hotfix/...。
      * Bad Pattern: feature/..., dev/..., temp などの曖昧な名前は禁止。自動化スクリプトがプレフィックスを頼りに処理を行うためである 1。
      * 権限: 作成者本人によるForce Push (git push -f) が許可される（PR作成前のみ）。これは、ローカルでのコミット整理（rebase/squash）を容易にするためである。
Layer 2: Integrate Branch (integrate)
      * 役割: 複数のFeature Branchを統合し、リリース前の最終検証を行うステージング環境。
      * 寿命: 中期（リリースサイクルに依存）。
      * マージ基準: Pull Request (PR) 必須。CIによるFull Verify通過、およびHumanGate承認が必須。
      * マージ方式: Squash and Merge。
      * 理由: Feature Branch上の試行錯誤の履歴（"WIP", "Fix typo"など）を圧縮し、integrate 上には「機能単位」のクリーンなコミットのみを残すため 9。
      * 保護設定: 直接Push禁止。履歴改変（Force Push）禁止。
Layer 3: Main Branch (main)
      * 役割: 本番環境にデプロイされる、絶対的な正本（SSOT）。
      * 寿命: 永続。
      * マージ基準: integrate からの昇格のみを受け入れる。
      * マージ方式: Create a Merge Commit (--no-ff)。
      * 理由: 「いつ統合が行われたか」というリリースイベント自体の履歴を明示的に残すため。これにより、問題発生時に「どのリリースの塊（Merge Commit）をRevertすべきか」が明確になる。
      * 保護設定: 最上級の保護。管理者であっても直接Pushは不可。GPG署名必須 10。
4.2 ブランチ保護ルールの技術的実装
GitHubの「Branch Protection Rules」設定画面において、以下の通り設定を行うことで、運用の強制力をシステム的に担保する 11。
対象ブランチ: main, integrate
      1. Require a pull request before merging (マージ前のPR必須)
      * Require approvals: 少なくとも 1名 以上。
      * Dismiss stale pull request approvals when new commits are pushed: 有効 (Check)。
      * 理由: 承認後にコードが変更された場合、その承認は無効化されるべきである。
      * Require review from Code Owners: 有効 (Check)。特定領域（例: VAULT/, sources/）の変更には専門家の承認を強制する。
      2. Require status checks to pass before merging (ステータスチェック必須)
      * Require branches to be up to date before merging: 有効 (Check)。
      * 理由: マージ先の最新状態に対してテストが通ることを保証するため。
      * Status checks: Verify Gate (Full), Sources Integrity Check を選択。
      3. Require signed commits (署名付きコミット必須): 有効 (Check)。
      4. Include administrators (管理者を含める): 有効 (Check)。
      * 理由: 「特権IDでの誤操作」こそが最大の事故要因であるため、例外を設けない 13。
4.3 マージ戦略と履歴管理の比較
なぜ場所によってマージ方式を変えるのか、その理論的背景を以下に示す。
マージ方式
	採用場所
	理由と効果
	Squash and Merge
	feat → integrate
	Feature作業中の「試行錯誤」はノイズである。これらを1つのコミットに圧縮することで、integrate の履歴は「何機能を追加したか」という意味のある単位のみで構成される。git blame の有用性が向上する。
	Create Merge Commit
	integrate → main
	リリースは「イベント」である。複数の機能が含まれる統合を1つのマージコミットとして記録することで、履歴上で「ここからここまでがv1.0」という区切りが視覚的に明確になる。ロールバック時も、このマージコミット1つを revert するだけで済む。
	Rebase and Merge
	原則不採用
	履歴が直線的になりすぎるため、機能の導入境界が見えにくくなるリスクがある。SSOT運用では「文脈」を残すことが重要であるため、採用しない。
	4.4 回復手順とアンチパターン
運用において「間違えたとき」の対応手順（Recovery）を明確にすることで、パニックによる二次被害を防ぐ 1。
シナリオA：ローカルでの作業ミス（Push前）
      * 状況: 間違ったファイルをコミットした、メッセージをミスした。
      * 処置: git reset --soft HEAD~1
      * 解説: 直前のコミットを取り消すが、変更内容はステージング状態（インデックス）に残る。修正して再コミットが可能。
      * アンチパターン: git reset --hard は、作業内容自体を消し去るため、よほどの確信がない限り使用しない。
シナリオB：共有ブランチへの誤マージ（Push後）
      * 状況: integrate にバグを含むコードをマージしてしまった。
      * 処置: git revert -m 1 <merge-commit-hash>
      * 解説: 「そのコミットを打ち消す新しいコミット」を作成する。履歴を改変せず、ミスの事実とその修正を記録に残す。
      * アンチパターン: git reset や git push -f で共有ブランチの時間を巻き戻すことは厳禁である。他の開発者のローカル環境との整合性が破壊され、チーム全体の作業が停止する原因となる 1。
________________
5. 第4章：Verify Gateシステムと証跡管理
SSOTの品質を担保する自動化ゲートキーパー「Verify Gate」の詳細設計である。ここでは、ローカルでの「軽快さ」とCIでの「厳密さ」を両立させる仕組みと、証跡（Evidence）の取り扱いについて規定する。
5.1 Fast Verify (Local) vs Full Verify (CI)
検証プロセスを2段階に分けることで、開発者の体験（DX）を損なわずに品質を担保する。
特徴
	Fast Verify (Local)
	Full Verify (CI)
	実行場所
	開発者のローカルマシン (PowerShell)
	GitHub Actions Runner (Ubuntu Latest)
	実行コマンド
	pwsh./checks/verify_repo.ps1 -Mode Fast
	pwsh./checks/verify_repo.ps1 -Mode Full
	所要時間
	5秒以内 (目標)
	5分〜30分
	検証項目
	・Markdownリンク切れチェック


・必須ファイル存在確認


・禁止用語/コマンドチェック


・Gitコンフリクトマーカー検出


・sources/ 改変チェック (簡易)
	Fastの全項目 に加えて：


・外部リンクの生存確認 (HTTP Request)


・セキュリティスキャン (Secret/SBOM)


・RAGキャッシュ整合性確認


・スペルチェック


・依存関係のライセンス確認
	目的
	コミット前の最低限のサニタイズ。


「うっかりミス」の即時フィードバック。
	リリース基準の厳格な適用。


外部要因を含む包括的な保証。
	5.2 検証スクリプトの実装ロジック (verify_repo.ps1)
スクリプトの中核ロジックについて、技術的な裏付けを持って解説する 7。
5.2.1 リンク切れ検出 (Fast)
正規表現 \[([^\]]+)\]\(([^)]+)\.md\) を用いてMarkdown内の内部リンクを抽出し、Test-Path コマンドレットでファイルの存在を確認する。これはファイルシステムへのアクセスのみで完結するため、極めて高速である。
5.2.2 Sources完全性チェック (Source Integrity)
sources/ ディレクトリは「事実の台帳」であり、過去の記録（ファイル）が変更・削除されることはあってはならない。しかし、新しい事実（ファイル）の追加は許可される。このロジックをGitコマンドで実装する 7。


PowerShell




# Git Diff Filter Logic
# A: Added, M: Modified, D: Deleted
# sources/ディレクトリにおける M または D を検出する
$violation = git diff --name-status HEAD~1 HEAD -- sources/ | Select-String "^"

if ($violation) {
   # 変更または削除が見つかった場合 -> FAIL
   Write-Error "CRITICAL VIOLATION: Existing files in sources/ were modified or deleted."
   exit 1
} else {
   # 追加(A)のみ、または変更なし -> PASS
   Write-Host "Sources Integrity: PASS"
}

このロジックにより、「整理整頓」という名目での過去ログ改変を機械的に阻止する。
5.2.3 コンフリクトマーカー検出
Gitのマージ競合時に自動挿入される <<<<<<< HEAD などのマーカーが、解決されないままコミットされる事故を防ぐ。スクリプトは全テキストファイルをスキャンし、これらのパターンが含まれていれば即座にFAIL判定を下す 7。
5.3 証跡管理ポリシー (Evidence Policy)
証跡ファイルが無限に増殖する問題（P1-003）を解決するため、「Recent-3」ポリシーを導入する。
      * 命名規則: YYYYMMDD_HHMMSS_<Mode>_<Status>.md
      * 例: 20260112_100000_Fast_PASS.md
      * 拡張子を .md に統一することで、GitHub上でのプレビュー性を高める（P0-003の解消）1。
      * 保持ルール (Recent-3):
      * 同一チケット/コンテキストにつき、最新の3件のみを保持する。
      * 新しい証跡を生成した際、古い証跡が3件を超えていれば、最も古いものを自動的に evidence/archive/YYYY/ ディレクトリへ移動（アーカイブ）する。
      * 削除禁止: 証跡を完全に削除することは禁止する。アーカイブ領域に移すことで、ディレクトリの見通しを良くしつつ、監査可能性を維持する。
自動ローテーションの実装 (cleanup_evidence.ps1)
このスクリプトは verify_repo.ps1 の最後に自動的に呼び出される。


PowerShell




# cleanup_evidence.ps1 (Concept)
$limit = 3
$evidenceDir = "evidence/verify_reports"
$archiveDir = "evidence/archive/$(Get-Date -Format 'yyyy')"

# ファイルを作成日時順にソート
$files = Get-ChildItem $evidenceDir -Filter "*.md" | Sort-Object CreationTime -Descending

# 閾値を超えた分をアーカイブへ移動
if ($files.Count -gt $limit) {
   $filesToArchive = $files | Select-Object -Skip $limit
   foreach ($file in $filesToArchive) {
       Move-Item -Path $file.FullName -Destination $archiveDir -Force
   }
}

________________
6. 第5章：混乱ポイント解消FAQ (Zero Confusion Guide)
ユーザーが抱きがちな疑問や誤解（Confusion Points）を先回りして解決する。これらは「運用における迷い」を断つための道標である。
Q1. コミットメッセージを間違えました。修正できますか？
Yes/No: Push前なら Yes。Push後なら No。
解説: まだ git push していないなら、git commit --amend で修正可能です。しかし、一度共有ブランチ（featであってもPR中なら共有とみなす）にPushした後は、履歴を書き換えるべきではありません。間違いも含めて履歴として残し、必要なら次のコミットで訂正してください。
Q2. docs/Part01.md でコンフリクトが発生しました。どうすれば？
手順:
      1. パニックにならない: コンフリクトは日常茶飯事です。
      2. 最新を取得: git fetch origin main
      3. リベース: git rebase origin/main
      4. 解決: エディタで <<<<<<< 箇所を確認。「自分の変更（Current）」か「相手の変更（Incoming）」か、あるいは「両方の統合」かを選びます。
      5. 検証: 解決後、必ず Fast Verify を実行し、文法エラーがないか確認してください。
Q3. 誤字脱字の修正など、小さな変更なら main で直接直してもいいですか？
No. 絶対にダメです。
解説: 「小さな変更」の定義は人によって異なります。例外を許せば、やがて「緊急だから」と大きな変更も直接行われるようになります。システム（Branch Protection）があなたのPushを拒否するはずです。必ず feat/fix-typo ブランチを作り、PRを通してください。Tier 2 (PatchOnly) ツールを使えば、この作業は数分で完了します。
Q4. ログの要約や整理にはどのAIを使えばいいですか？
回答: Tier 2 (PatchOnly) のツール（Z.ai Lite, Copilotなど）を使用してください。
解説: GPT-4のような高価で高性能なモデル（Tier 3）を単純作業に使うのは資源の無駄です。また、Tier 2ツールは権限が制限されているため、誤って重要なファイルを消すリスクも低減されます。
Q5. Claude Codeが sources/ 内のファイルを整理（削除・統合）しようとしています。許可すべきですか？
No.
解説: sources/ は「一次情報の保管場所」であり、ゴミ箱ではありません。ファイル名が汚くても、内容が重複していても、それが「その時点で取得した生の事実」であれば、変更すべきではありません。新しい整理されたファイルを作成し、古いファイルを残す形（追記）のみ許可してください。
Q6. ローカルでは Verify が通るのに、CI (GitHub Actions) で落ちます。なぜですか？
回答: 外部リンク切れや、セキュリティスキャンで引っかかっている可能性が高いです。
解説: ローカルの Fast Verify は速度優先のため、外部通信や重いスキャンをスキップしています。GitHub Actionsのログを確認し、具体的なエラー内容（例: 404 Not Found, Secret detected）を特定してください。
Q7. PRの承認者は誰ですか？
回答: decisions/0004-humangate-approvers.md を確認してください。
解説: プロジェクトごとに定義された「HumanGate権限者」のみが承認できます。もし緊急で承認者が不在（4時間以上連絡がつかない等）の場合は、Emergency Protocol（パッチ#1参照）に従い、代理承認者2名の合意で進めることができます。
Q8. "Evidence" ファイルとは何ですか？なぜ必要なのですか？
回答: verify_repo.ps1 が生成するMarkdownレポートです。
解説: これあなたの作業が「SSOTの基準を満たしている」ことを客観的に証明する唯一の手段です。「テストしました」という口頭報告は信用されません。証跡ファイルがPRに含まれていない場合、そのPRはレビューされることなく却下されます。
Q9. 古い Evidence ファイルを手動で削除してもいいですか？
No.
解説: 手動削除は事故の元です。verify_repo.ps1 を実行するたびに、cleanup_evidence.ps1 が自動的に走り、古いファイルをアーカイブフォルダに移動してくれます。あなたはファイル整理を気にする必要はありません。
Q10. ドキュメントに矛盾を見つけました。すぐに修正すべきですか？
No. まずADRを作成してください。
解説: 矛盾の解消は「アーキテクチャの変更」を意味する場合があります。なぜ矛盾していたのか、どう直すべきかを decisions/ にADRとして記録し、それが承認されて初めてドキュメントを修正できます。手順は ADR作成 -> 承認 -> docs修正 です。
________________
7. 第6章：一本道Runbook (The Single Path Runbook)
迷いを排除するための、分岐のない標準作業手順書である。開発者はこの手順を上から順になぞるだけで、正しく安全に変更を完了できる。
Phase A: 準備 (Initialization)
      1. ** リモート最新化**: git checkout main -> git pull origin main
      2. ** ブランチ作成**: git checkout -b feat/<TICKET-ID>-<description>
      * Check: ブランチ名は feat/ か fix/ で始まっているか？ (Yes: 次へ / No: 作り直し)
Phase B: 実装 (Implementation)
      3. ** コード/ドキュメント編集**: 必要な変更を行う。
      * Rule: sources/ の既存ファイルには触れない。
      4. [CLI] Fast Verify実行: pwsh./checks/verify_repo.ps1 -Mode Fast
      * Check: 結果は PASS か？
      * No: エラー箇所を修正し、手順4へ戻る。
      * Yes: evidence/ にレポートが生成されたことを確認し、次へ。
Phase C: 保存 (Commit & Push)
      5. [CLI] ステージング: git add.
      6. [CLI] コミット: git commit -m "feat(Scope): Message"
      * Auto: pre-commit フックが走り、sources/ 改変がないか最終チェックされる。
      7. [CLI] プッシュ: git push -u origin feat/<TICKET-ID>-...
Phase D: 統合 (Integration)
      8. [GitHub] PR作成: feat ブランチから integrate ブランチに対してPRを作成。
      * Action: PRテンプレートを記入し、Evidenceファイルのパスを記載。
      9. [CI] Full Verify待機: GitHub Actionsの完了を待つ。
      * Check: オールグリーンか？ (Yes: 次へ / No: ローカルで修正しPush、手順4へ戻る)
      10. [GitHub] HumanGate承認: レビュアーにレビューを依頼。
      * Check: Approvedされたか？ (Yes: 次へ)
      11. [GitHub] マージ: "Squash and merge" ボタンを押す。
      12. [GitHub] ブランチ削除: 作業済みブランチを削除。
________________
8. 第7章：修正パッチ案と実装計画
調査で判明した重要課題（P0）を解決するための具体的な修正パッチである。これらは直ちにリポジトリに適用されるべきである。
8.1 Patch #1: HumanGate定義の明確化 (Fixing P0-001)
課題: HumanGateの承認者が誰か、どのような権限か定義されていない。
ファイル: docs/Part09.md
操作: 以下のセクションを追記する。
5.1.5 HumanGate Authority & Protocol (2026-01-12 Defined)
定義: HumanGateとは、SSOTアーキテクチャおよびintegrate/mainブランチへの変更に対し、人間が明示的に行う承認プロセスである。
承認権限者 (Authorized Approvers):
      1. Lead Architect: - Part00-10の設計変更に対する拒否権を持つ。
      2. Security Lead: - VAULT, Auth, MCP設定に対する拒否権を持つ。
      3. Emergency Proxy: リード不在時（4時間以上）に限り、Senior Developer 2名の合意で承認を代行できる。
承認メカニズム:
      * 通常時: GitHub PR上の "Review changes" -> "Approve"。
      * 緊急時: Issueコメントでの "LGTM (Emergency Override)" 宣言 + 音声/チャットでの確認。
8.2 Patch #2: Evidence拡張子の統一 (Fixing P0-003)
課題: Part 10 (.txt) と Part 12 (.md) で記述が矛盾している。
ファイル: docs/Part10.md
操作: 以下の記述に書き換える。
証跡ファイルのフォーマット
全ての証跡ファイル（Evidence）は、GitHub上での可読性を確保するため、Markdown形式 (.md) を使用しなければならない。
ファイル名規則: YYYYMMDD_HHMMSS_<Mode>_<Status>.md
8.3 Patch #3: Sources完全性保護ロジック (Fixing P0-005)
課題: sources/ の改変禁止を検証する具体的なロジックが存在しない。
ファイル: checks/verify_sources_integrity.ps1 (新規作成)
内容:


PowerShell




<#
.SYNOPSIS
   sources/ ディレクトリの不変性（Immutability）を検証する。
   新規追加（A）は許可し、変更（M）と削除（D）を禁止する。
#>
param([string]$TargetRef = "HEAD")

# Git Diff Filter: M(odified) または D(eleted) を検出
# --diff-filter=MD オプションを使用
$violations = git diff --name-only --diff-filter=MD $TargetRef~1 $TargetRef -- sources/

if ($violations) {
   Write-Host "[FAIL] CRITICAL: The following files in sources/ were modified or deleted:" -ForegroundColor Red
   $violations | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
   Write-Host "Action: Revert changes to sources/ immediately."
   exit 1
} else {
   Write-Host " Sources Integrity: No modifications or deletions detected." -ForegroundColor Green
   exit 0
}

8.4 Patch #4: MCPセキュリティ基準の更新 (Fixing P0-006)
課題: MCPのセキュリティ要件が2025年基準（OAuth 2.1必須化）に追いついていない。
ファイル: docs/Part03.md
操作: Securityセクションを以下のように更新する。
MCP Security Standards (2026 Update)
      * Protocol: OAuth 2.1 準拠を必須とする。Implicit Flowの使用は禁止。
      * PKCE: 全てのクライアント（Public/Confidential問わず）において PKCE (Proof Key for Code Exchange) を実装しなければならない。
      * Token Storage: アクセストークンはOSのセキュアストレージ（Keychain等）に保存し、平文ファイルへの保存を禁止する。
      * User Consent: ツール実行要求時、リスク評価に基づきユーザーの明示的同意（Consent）を取得するフローを実装すること。
________________
9. 結論
本報告書で提示した「役割分担マトリクス」、「一本道Runbook」、「修正パッチ」を適用することで、VCG/VIBEプロジェクトにおける運用上の迷いは構造的に排除される。
特に、「ローカルはFast Verify、CIはFull Verify」という明確な分担と、「Sourcesディレクトリへの追記のみ許可」という機械的な制約は、SSOTの信頼性を維持する防波堤となる。また、「Recent-3」ポリシーによる証跡の自動整理は、監査可能性と持続可能性を両立させる現実解である。
直ちにこれらのパッチを適用し、チーム全体にRunbookを周知することを推奨する。これにより、システムは「個人の注意深さ」に依存する状態から、「プロセスの堅牢さ」によって守られる状態へと進化する。
参照URL
      * 1 VCG/VIBE Design Report Part 1 (Contradictions)
      * 1 VCG/VIBE Design Report Part 2 (Tool/Git Design)
      * 1 VCG/VIBE Design Report Part 3 (Scenarios & Scripts)
      * 2 MCP Security & OAuth 2.1 Specs
      * 11 GitHub Branch Protection Documentation
      * 7 Git Diff Filter Documentation
引用文献
      1. VCG_VIBE_設計調査レポート_Part2.txt
      2. Authorization - Model Context Protocol, 1月 12, 2026にアクセス、 https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization
      3. MCP, OAuth 2.1, PKCE, and the Future of AI Authorization - Aembit, 1月 12, 2026にアクセス、 https://aembit.io/blog/mcp-oauth-2-1-pkce-and-the-future-of-ai-authorization/
      4. Authorization - Model Context Protocol, 1月 12, 2026にアクセス、 https://modelcontextprotocol.io/specification/draft/basic/authorization
      5. PowerShell script that monitors file integrity by tracking file creation, changes, and deletions in a specified directory, logging events, and sending email alerts when discrepancies are detected based on a pre-collected baseline of file hashes. - GitHub, 1月 12, 2026にアクセス、 https://github.com/sdwyersec/File-Integrity-Monitor
      6. Check if specific file in git repository has changed - Stack Overflow, 1月 12, 2026にアクセス、 https://stackoverflow.com/questions/17797740/check-if-specific-file-in-git-repository-has-changed
      7. Public/Get-GitChangedFile.ps1 2.0.16 - PowerShell Gallery, 1月 12, 2026にアクセス、 https://www.powershellgallery.com/packages/BuildHelpers/2.0.16/Content/Public%5CGet-GitChangedFile.ps1
      8. Understanding Authorization in MCP - Model Context Protocol, 1月 12, 2026にアクセス、 https://modelcontextprotocol.io/docs/tutorials/security/authorization
      9. Understanding GitHub branch protection rules - Graphite, 1月 12, 2026にアクセス、 https://graphite.com/guides/github-branch-protection-rules
      10. GitHub Best Practices - Webstandards - CA.gov, 1月 12, 2026にアクセス、 https://webstandards.ca.gov/2023/04/19/github-best-practices/
      11. Managing a branch protection rule - GitHub Docs, 1月 12, 2026にアクセス、 https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule
      12. About protected branches - GitHub Docs, 1月 12, 2026にアクセス、 https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches
      13. GitOpsSecurityChampion/docs/resources/branch-protection/README.md at main - GitHub, 1月 12, 2026にアクセス、 https://github.com/CycodeLabs/GitOpsSecurityChampion/blob/main/docs/resources/branch-protection/README.md
      14. PowerShell/scripts/check-repo.ps1 at main - GitHub, 1月 12, 2026にアクセス、 https://github.com/fleschutz/PowerShell/blob/main/scripts/check-repo.ps1
      15. Functions/Public/Repositories/Get-GitHubRepository.ps1 0.15.230 - PowerShell Gallery, 1月 12, 2026にアクセス、 https://www.powershellgallery.com/packages/PSGitHub/0.15.230/Content/Functions%5CPublic%5CRepositories%5CGet-GitHubRepository.ps1
      16. How to use git diff while excluding files - Graphite, 1月 12, 2026にアクセス、 https://graphite.com/guides/git-diff-exclude-files
      17. git diff-filter - DEV Community, 1月 12, 2026にアクセス、 https://dev.to/waylonwalker/git-diff-filter-4dg4