### USER
あなたは「外部仕様・最新動向の一次情報確認」担当です。
添付の DESIGN_MASTER と調査レポート Part1-3 を前提に、2026年時点で設計に影響する“変わりやすい前提”を確定してください。

必須テーマ：
1) Model Context Protocol（MCP）の公式仕様と、実装上のセキュリティ/権限/境界の考え方
2) MCPサーバー運用で起きやすい事故（権限過大、秘密情報漏えい、ログ/証跡、外部取得の扱い）
3) 「ZAI（Z,AI）をMCPで使う」想定で、設計書に追加すべき注意点（APIキー、レート制限、情報源の記録、再現性）

情報源ルール：
- modelcontextprotocol.io 等の公式仕様/公式SDK/公式レポジトリを最優先。
- 公式に反する記述は採用しない。相違がある場合は“相違”として明記する。
- 重要な主張には必ず根拠URL（可能なら該当セクション）と日付を書く。

出力フォーマット：
A. 影響サマリ（設計書に必ず反映すべき変更点トップ7）
B. 設計追記の提案（章立て＋追記文案）
C. 運用チェックリスト（MCP/外部情報取得/ログ/権限/例外）
D. 参照URL一覧（一次情報中心）


### ASSISTANT
<details type="reasoning" done="true" duration="57" view="" last_tool_call_name="">
> 与えられた文書は、VCG/VIBE SSOT Design Masterに関する設計調査レポート（Part1～3）と、設計マスター（DESIGN_MASTER_20260111_230526.txt）のようです。これらの文書を基に、2026年時点で設計に影響する「変わりやすい前提」を確定する必要があります。
> 
> 特に、Model Context Protocol（MCP）に関する公式仕様と実装上のセキュリティ/権限/境界の考え方、MCPサーバー運用で起きやすい事故、そして「ZAI（Z,AI）をMCPで使う」想定での設計書への追加注意点について調査します。
> 
> 以下に、与えられた文書から関連する情報を整理します。
> 
> ### VCG/VIBE 設計調査レポート Part1 より関連部分
> 
> - **P0-006: MCPセキュリティが2025年スペックに準拠していない**
>   - 場所: Part03.md
>   - 問題: 2025年6月のOAuth Resource Server分類・2025年11月のUser Consent必須化に未対応
>   - 根拠: MCP Spec 2025-11-25「Hosts must obtain explicit user consent」
>   - 影響: 本番運用時のセキュリティポリシー不整合、機密情報漏洩リスク
> 
> - **修正案 #3: MCPセキュリティコンプライアンス追加**
>   - ファイル: docs/Part03.md
>   - 追加内容:
>     - User Consent（明示的opt-in）
>     - Data Privacy Boundary
>     - Tool Safety Gate
>     - OAuth 2.1 + RFC 8707 Compliance
> 
> ### VCG/VIBE 設計調査レポート Part2 より関連部分
> 
> - **4.1 ツール別最適担当表**
>   - SSOT構成解析: Claude Code CLI + verify_repo.ps1
>   - 仕様検討・ADR起草: ChatGPT (GPT-4.5)
>   - コード実装・テスト: Claude Code
>   - 外部仕様調査: Gemini CLI + MCP web
>   - 軽量タスク・ログ要約: Z.ai Lite
> 
> - **4.2 MCP活用プロンプト例**
>   - GitHub Issue整合性チェック
>   - Permission Tier違反検出
>   - MCP Cache一貫性チェック
>   - SSOT→RAG同期確認
>   - Agent Handoff ワークフロー検証
> 
> - **4.4 導入リスクと回避策**
>   - APIコスト増加: キャッシュ(TTL)運用、Batch API活用
>   - コンテキスト汚染: SSOT（docs/）を最優先、Verify Gate検証
>   - Permission昇格バイパス: Handoff時にPermission再確認
>   - 誤情報伝播: 毎日cache freshness check
>   - MCPサーバーダウン: Graceful fallback（ReadOnly cache）
>   - ハルシネーション: Verify Gateで最新SSOT確認
> 
> ### VCG/VIBE 設計調査レポート Part3 より関連部分
> 
> - **シナリオ3: MCP Toolが無制御実行→機密情報混入**
>   - 発生経路:
>     1. MCP Toolで読み込みファイル（APIキー混入）
>     2. sources/保存
>     3. Part00 U-0003暫定対応のまま
>     4. Incident時対応不明
>     5. 情報漏洩
>   - 予防策:
>     - User Consent + Tool Safety Gate 実装
>     - Data Privacy Boundary 明記
>     - Automated secret scanning（SBOM生成時）
>     - Part19にMCP Tool事故SOP追加
>     - VAULTに機密情報保管
> 
> - **9.1 verify_repo.ps1（メイン検証スクリプト）**
>   - Fast Verify: リンク切れ、Part存在、禁止コマンド、sources整合性、コンフリクトマーカー検出
>   - Evidence出力: タイムスタンプ、モード、ステータス、コミットハッシュ
> 
> ### DESIGN_MASTER_20260111_230526.txt より関連部分
> 
> - **Part03: AI Pack（Core4/Antigravity/MCP・役割固定・コンテキスト共有）**
>   - R-0301: Core4の役割固定
>   - R-0302: Antigravity の運用型
>   - R-0303: MCP導入方針（Phase 1: 読取系MCPから開始、Phase 2: 書込系は「Patch-only」「許可制」、Phase 3: 破壊系は HumanGate）
>   - R-0304: コンテキスト共有の原則
>   - R-0305: 軽量モデルの制限
>   - R-0306: AI間の責任分界
> 
> - **Part04: 作業管理（TICKET/VIBEKANBAN/WIP制限・タスクサイズ・進捗状態）**
>   - R-0401: TICKET 標準フォーマット
>   - R-0402: タスクサイズ分類
>   - R-0403: WIP制限
>   - R-0404: VIBEKANBAN の状態遷移
>   - R-0405: VIBEKANBAN の運用型
>   - R-0406: worktree 隔離の強制
>   - R-0407: BLOCKED 状態の解除条件明記
> 
> これらの情報を基に、MCPに関する2026年時点での「変わりやすい前提」を確定します。ただし、文書内に具体的なMCPの公式仕様に関する詳細な記述は少なく、特にMCP Spec 2025-11-25「Hosts must obtain explicit user consent」が唯一の公式仕様への言及です。
> 
> したがって、MCPの公式仕様に関する最新情報を得るために、外部の情報源を参照する必要があります。特に、modelcontextprotocol.io の公式仕様を確認することが重要です。
> 
> 以下に、modelcontextprotocol.io の公式仕様を確認するための検索クエリを考えます。
> 
> ### 検索クエリ
> - "Model Context Protocol official specification"
> - "MCP security model"
> - "MCP OAuth 2.1 compliance"
> - "MCP user consent requirement"
> - "MCP server implementation guide"
> 
> これらのクエリで得られる情報を基に、MCPの公式仕様と実装上のセキュリティ/権限/境界の考え方を整理します。
> 
> ### 次のアクション
> 1. modelcontextprotocol.io からMCPの公式仕様を確認します。
> 2. MCPサーバー運用で起きやすい事故（権限過大、秘密情報漏えい、ログ/証跡、外部取得の扱い）に関する情報を収集します。
> 3. 「ZAI（Z,AI）をMCPで使う」想定での設計書への追加注意点（APIキー、レート制限、情報源の記録、再現性）を考えます。
> 4. 上記の情報を基に、影響サマリ、設計追記の提案、運用チェックリスト、参照URL一覧を作成します。
> 
> では、まずmodelcontextprotocol.ioの公式仕様を確認します。
</details>

<glm_block view="" tool_call_name="search">{"data":{"browser":{"search_result":[{"title":"Specification","url":"https://modelcontextprotocol.io/specification/2025-11-25","text":"Model Context Protocol (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools.","index":1,"favicon":"","host_name":"modelcontextprotocol.io"},{"title":"Model Context Protocol","url":"https://modelcontextprotocol.io","text":"MCP (Model Context Protocol) is an open-source standard for connecting AI applications to external systems. Using MCP, AI applications like Claude or ...","index":2,"favicon":"","host_name":"modelcontextprotocol.io"},{"title":"Overview","url":"https://modelcontextprotocol.io/specification/2025-11-25/basic","text":"The full specification of the protocol is defined as a TypeScript schema. This is the source of truth for all protocol messages and ...","index":3,"favicon":"","host_name":"modelcontextprotocol.io"},{"title":"Overview - Model Context Protocol","url":"https://modelcontextprotocol.io/specification/2025-06-18/basic","text":"The full specification of the protocol is defined as a TypeScript schema. This is the source of truth for all protocol messages and ...","index":4,"favicon":"","host_name":"modelcontextprotocol.io"},{"title":"Architecture","url":"https://modelcontextprotocol.io/specification/2025-06-18/architecture","text":"The Model Context Protocol (MCP) follows a client-host-server architecture where each host can run multiple client instances.","index":5,"favicon":"","host_name":"modelcontextprotocol.io"},{"title":"Authorization","url":"https://modelcontextprotocol.io/specification/draft/basic/authorization","text":"This specification defines the authorization flow for HTTP-based transports. ​. Protocol Requirements. Authorization is OPTIONAL for MCP implementations. When ...","index":6,"favicon":"","host_name":"modelcontextprotocol.io"},{"title":"Tools","url":"https://modelcontextprotocol.io/specification/2025-06-18/server/tools","text":"The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by language models. Tools enable models to interact with ...","index":7,"favicon":"","host_name":"modelcontextprotocol.io"},{"title":"Versioning","url":"https://modelcontextprotocol.io/specification/versioning","text":"The Model Context Protocol uses string-based version identifiers following the format YYYY-MM-DD , to indicate the last date backwards incompatible changes ...","index":8,"favicon":"","host_name":"modelcontextprotocol.io"},{"title":"Architecture overview","url":"https://modelcontextprotocol.io/docs/learn/architecture","text":"This overview of the Model Context Protocol (MCP) discusses its scope and core concepts, and provides an example demonstrating each core concept.","index":9,"favicon":"","host_name":"modelcontextprotocol.io"},{"title":"Resources","url":"https://modelcontextprotocol.io/specification/2025-06-18/server/resources","text":"The Model Context Protocol (MCP) provides a standardized way for servers to expose resources to clients. Resources allow servers to share data ...","index":10,"favicon":"","host_name":"modelcontextprotocol.io"}]},"metadata":{"arguments":"{\"query\":\"Model Context Protocol official specification site:modelcontextprotocol.io\"}","display_result":"","duration":"2s","id":"call_Cz9zrhzkQA","is_error":false,"mcp_server":{"name":"mcp-server"},"name":"search","result":"【0†Specification†https://modelcontextprotocol.io/specification/2025-11-25】\nModel Context Protocol (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools.\n\n【1†Model Context Protocol†https://modelcontextprotocol.io】\nMCP (Model Context Protocol) is an open-source standard for connecting AI applications to external systems. Using MCP, AI applications like Claude or ...\n\n【2†Overview†https://modelcontextprotocol.io/specification/2025-11-25/basic】\nThe full specification of the protocol is defined as a TypeScript schema. This is the source of truth for all protocol messages and ...\n\n【3†Overview - Model Context Protocol†https://modelcontextprotocol.io/specification/2025-06-18/basic】\nThe full specification of the protocol is defined as a TypeScript schema. This is the source of truth for all protocol messages and ...\n\n【4†Architecture†https://modelcontextprotocol.io/specification/2025-06-18/architecture】\nThe Model Context Protocol (MCP) follows a client-host-server architecture where each host can run multiple client instances.\n\n【5†Authorization†https://modelcontextprotocol.io/specification/draft/basic/authorization】\nThis specification defines the authorization flow for HTTP-based transports. ​. Protocol Requirements. Authorization is OPTIONAL for MCP implementations. When ...\n\n【6†Tools†https://modelcontextprotocol.io/specification/2025-06-18/server/tools】\nThe Model Context Protocol (MCP) allows servers to expose tools that can be invoked by language models. Tools enable models to interact with ...\n\n【7†Versioning†https://modelcontextprotocol.io/specification/versioning】\nThe Model Context Protocol uses string-based version identifiers following the format YYYY-MM-DD , to indicate the last date backwards incompatible changes ...\n\n【8†Architecture overview†https://modelcontextprotocol.io/docs/learn/architecture】\nThis overview of the Model Context Protocol (MCP) discusses its scope and core concepts, and provides an example demonstrating each core concept.\n\n【9†Resources†https://modelcontextprotocol.io/specification/2025-06-18/server/resources】\nThe Model Context Protocol (MCP) provides a standardized way for servers to expose resources to clients. Resources allow servers to share data ...\n","status":"completed"}},"type":"mcp"}</glm_block>


<details type="reasoning" done="true" duration="8" view="" last_tool_call_name="search">
> MCPの公式仕様に関する情報が得られました。特に、2025-11-25と2025-06-18の2つのバージョンが存在することがわかります。設計レポートでは2025-11-25の仕様に言及があるため、こちらを中心に確認します。
> 
> ### 重要なポイント
> 1. **MCPのバージョニング**: `YYYY-MM-DD`形式で、後方互換性のない変更があった最終日を示します。
> 2. **認証（Authorization）**: HTTPベースのトランスポート向けの認証フローが定義されていますが、認証はオプションです。
> 3. **アーキテクチャ**: クライアント-ホスト-サーバーアーキテクチャに従います。
> 4. **ツール（Tools）**: サーバーが言語モデルによって呼び出されるツールを公開できます。
> 5. **リソース（Resources）**: サーバーがクライアントにデータを共有するための標準化された方法。
> 
> 次に、MCPのセキュリティモデルや認証に関する詳細を確認します。特に、2025-11-25の仕様で「Hosts must obtain explicit user consent」という要件があるようですので、その詳細を確認します。
</details>

<glm_block view="" tool_call_name="click">{"data":{"browser":{"url":"https://modelcontextprotocol.io/specification/2025-11-25","title":"Specification","content":"【0†Specification†https://modelcontextprotocol.io/specification/2025-11-25】\nTitle: Specification - Model Context Protocol\n\nURL Source: https://modelcontextprotocol.io/specification/2025-11-25\n\nMarkdown Content:\nModel Context Protocol (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating custom AI workflows, MCP provides a standardized way to connect LLMs with the context they need.This specification defines the authoritative protocol requirements, based on the TypeScript schema in schema.ts.For implementation guides and examples, visit modelcontextprotocol.io.The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.\n\nOverview\n--------\n\nMCP provides a standardized way for applications to:\n\n*   Share contextual information with language models\n*   Expose tools and capabilities to AI systems\n*   Build composable integrations and workflows\n\nThe protocol uses JSON-RPC 2.0 messages to establish communication between:\n\n*   **Hosts**: LLM applications that initiate connections\n*   **Clients**: Connectors within the host application\n*   **Servers**: Services that provide context and capabilities\n\nMCP takes some inspiration from the Language Server Protocol, which standardizes how to add support for programming languages across a whole ecosystem of development tools. In a similar way, MCP standardizes how to integrate additional context and tools into the ecosystem of AI applications.\n\nKey Details\n-----------\n\n### Base Protocol\n\n*   JSON-RPC message format\n*   Stateful connections\n*   Server and client capability negotiation\n\n### Features\n\nServers offer any of the following features to clients:\n\n*   **Resources**: Context and data, for the user or the AI model to use\n*   **Prompts**: Templated messages and workflows for users\n*   **Tools**: Functions for the AI model to execute\n\nClients may offer the following features to servers:\n\n*   **Sampling**: Server-initiated agentic behaviors and recursive LLM interactions\n*   **Roots**: Server-initiated inquiries into URI or filesystem boundaries to operate in\n*   **Elicitation**: Server-initiated requests for additional information from users\n\n### Additional Utilities\n\n*   Configuration\n*   Progress tracking\n*   Cancellation\n*   Error reporting\n*   Logging\n\nSecurity and Trust & Safety\n---------------------------\n\nThe Model Context Protocol enables powerful capabilities through arbitrary data access and code execution paths. With this power comes important security and trust considerations that all implementors must carefully address.\n\n### Key Principles\n\n1.   **User Consent and Control**\n    *   Users must explicitly consent to and understand all data access and operations\n    *   Users must retain control over what data is shared and what actions are taken\n    *   Implementors should provide clear UIs for reviewing and authorizing activities\n\n2.   **Data Privacy**\n    *   Hosts must obtain explicit user consent before exposing user data to servers\n    *   Hosts must not transmit resource data elsewhere without user consent\n    *   User data should be protected with appropriate access controls\n\n3.   **Tool Safety**\n    *   Tools represent arbitrary code execution and must be treated with appropriate caution. \n        *   In particular, descriptions of tool behavior such as annotations should be considered untrusted, unless obtained from a trusted server.\n\n    *   Hosts must obtain explicit user consent before invoking any tool\n    *   Users should understand what each tool does before authorizing its use\n\n4.   **LLM Sampling Controls**\n    *   Users must explicitly approve any LLM sampling requests\n    *   Users should control: \n        *   Whether sampling occurs at all\n        *   The actual prompt that will be sent\n        *   What results the server can see\n\n    *   The protocol intentionally limits server visibility into prompts\n\n### Implementation Guidelines\n\nWhile MCP itself cannot enforce these security principles at the protocol level, implementors **SHOULD**:\n\n1.   Build robust consent and authorization flows into their applications\n2.   Provide clear documentation of security implications\n3.   Implement appropriate access controls and data protections\n4.   Follow security best practices in their integrations\n5.   Consider privacy implications in their feature designs\n\nLearn More\n----------\n\nExplore the detailed specification for each protocol component:\n\n"},"metadata":{"arguments":"{\"link_id\":0}","display_result":"","duration":"1s","id":"call_gnEv0SabpP","is_error":false,"mcp_server":{"name":"mcp-server"},"name":"click","result":"【0†Specification†https://modelcontextprotocol.io/specification/2025-11-25】\nTitle: Specification - Model Context Protocol\n\nURL Source: https://modelcontextprotocol.io/specification/2025-11-25\n\nMarkdown Content:\nModel Context Protocol (MCP) is an open protocol that enables seamless integration between LLM applications and external data sources and tools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating custom AI workflows, MCP provides a standardized way to connect LLMs with the context they need.This specification defines the authoritative protocol requirements, based on the TypeScript schema in schema.ts.For implementation guides and examples, visit modelcontextprotocol.io.The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.\n\nOverview\n--------\n\nMCP provides a standardized way for applications to:\n\n*   Share contextual information with language models\n*   Expose tools and capabilities to AI systems\n*   Build composable integrations and workflows\n\nThe protocol uses JSON-RPC 2.0 messages to establish communication between:\n\n*   **Hosts**: LLM applications that initiate connections\n*   **Clients**: Connectors within the host application\n*   **Servers**: Services that provide context and capabilities\n\nMCP takes some inspiration from the Language Server Protocol, which standardizes how to add support for programming languages across a whole ecosystem of development tools. In a similar way, MCP standardizes how to integrate additional context and tools into the ecosystem of AI applications.\n\nKey Details\n-----------\n\n### Base Protocol\n\n*   JSON-RPC message format\n*   Stateful connections\n*   Server and client capability negotiation\n\n### Features\n\nServers offer any of the following features to clients:\n\n*   **Resources**: Context and data, for the user or the AI model to use\n*   **Prompts**: Templated messages and workflows for users\n*   **Tools**: Functions for the AI model to execute\n\nClients may offer the following features to servers:\n\n*   **Sampling**: Server-initiated agentic behaviors and recursive LLM interactions\n*   **Roots**: Server-initiated inquiries into URI or filesystem boundaries to operate in\n*   **Elicitation**: Server-initiated requests for additional information from users\n\n### Additional Utilities\n\n*   Configuration\n*   Progress tracking\n*   Cancellation\n*   Error reporting\n*   Logging\n\nSecurity and Trust & Safety\n---------------------------\n\nThe Model Context Protocol enables powerful capabilities through arbitrary data access and code execution paths. With this power comes important security and trust considerations that all implementors must carefully address.\n\n### Key Principles\n\n1.   **User Consent and Control**\n    *   Users must explicitly consent to and understand all data access and operations\n    *   Users must retain control over what data is shared and what actions are taken\n    *   Implementors should provide clear UIs for reviewing and authorizing activities\n\n2.   **Data Privacy**\n    *   Hosts must obtain explicit user consent before exposing user data to servers\n    *   Hosts must not transmit resource data elsewhere without user consent\n    *   User data should be protected with appropriate access controls\n\n3.   **Tool Safety**\n    *   Tools represent arbitrary code execution and must be treated with appropriate caution. \n        *   In particular, descriptions of tool behavior such as annotations should be considered untrusted, unless obtained from a trusted server.\n\n    *   Hosts must obtain explicit user consent before invoking any tool\n    *   Users should understand what each tool does before authorizing its use\n\n4.   **LLM Sampling Controls**\n    *   Users must explicitly approve any LLM sampling requests\n    *   Users should control: \n        *   Whether sampling occurs at all\n        *   The actual prompt that will be sent\n        *   What results the server can see\n\n    *   The protocol intentionally limits server visibility into prompts\n\n### Implementation Guidelines\n\nWhile MCP itself cannot enforce these security principles at the protocol level, implementors **SHOULD**:\n\n1.   Build robust consent and authorization flows into their applications\n2.   Provide clear documentation of security implications\n3.   Implement appropriate access controls and data protections\n4.   Follow security best practices in their integrations\n5.   Consider privacy implications in their feature designs\n\nLearn More\n----------\n\nExplore the detailed specification for each protocol component:\n\n","status":"completed"}},"type":"mcp"}</glm_block>


<details type="reasoning" done="true" duration="14" view="" last_tool_call_name="click">
> MCPの2025-11-25仕様から、セキュリティと信頼性に関する重要な原則が明記されています。特に、ユーザーの同意と制御、データプライバシー、ツールの安全性、LLMサンプリング制御が強調されています。
> 
> ### セキュリティ原則の要点
> 1. **User Consent and Control**:
>    - ユーザーはすべてのデータアクセスと操作に明示的に同意し、理解する必要があります。
>    - ユーザーは共有されるデータと実行される操作を制御する必要があります。
>    - 実装者は、アクティビティをレビューおよび承認するための明確なUIを提供すべきです。
> 
> 2. **Data Privacy**:
>    - ホストは、ユーザーデータをサーバーに公開する前に、明示的なユーザーの同意を得る必要があります。
>    - ホストは、ユーザーの同意なしにリソースデータを他の場所に送信してはなりません。
>    - ユーザーデータは適切なアクセス制御で保護する必要があります。
> 
> 3. **Tool Safety**:
>    - ツールは任意のコード実行を表すため、適切な注意をもって扱う必要があります。
>    - 特に、ツールの動作に関する説明（注釈など）は、信頼できるサーバーから取得されない限り、信頼できないと見なすべきです。
>    - ホストは、ツールを呼び出す前に明示的なユーザーの同意を得る必要があります。
>    - ユーザーは、各ツールが何をするかを理解してからその使用を承認する必要があります。
> 
> 4. **LLM Sampling Controls**:
>    - ユーザーは、LLMサンプリング要求を明示的に承認する必要があります。
>    - ユーザーは、サンプリングが発生するかどうか、送信される実際のプロンプト、サーバーがどの結果を見ることができるかを制御する必要があります。
>    - プロトコルは意図的にサーバーがプロンプトを見ることを制限しています。
> 
> 次に、認証に関する詳細を確認します。
</details>

<glm_block view="" tool_call_name="click">{"data":{"browser":{"url":"https://modelcontextprotocol.io/specification/draft/basic/authorization","title":"Authorization","content":"【5†Authorization†https://modelcontextprotocol.io/specification/draft/basic/authorization】\nTitle: Authorization - Model Context Protocol\n\nURL Source: https://modelcontextprotocol.io/specification/draft/basic/authorization\n\nMarkdown Content:\nIntroduction\n------------\n\n### Purpose and Scope\n\nThe Model Context Protocol provides authorization capabilities at the transport level, enabling MCP clients to make requests to restricted MCP servers on behalf of resource owners. This specification defines the authorization flow for HTTP-based transports.\n\n### Protocol Requirements\n\nAuthorization is **OPTIONAL** for MCP implementations. When supported:\n\n*   Implementations using an HTTP-based transport **SHOULD** conform to this specification.\n*   Implementations using an STDIO transport **SHOULD NOT** follow this specification, and instead retrieve credentials from the environment.\n*   Implementations using alternative transports **MUST** follow established security best practices for their protocol.\n\n### Standards Compliance\n\nThis authorization mechanism is based on established specifications listed below, but implements a selected subset of their features to ensure security and interoperability while maintaining simplicity:\n\n*   OAuth 2.1 IETF DRAFT (draft-ietf-oauth-v2-1-13)\n*   OAuth 2.0 Authorization Server Metadata (RFC8414)\n*   OAuth 2.0 Dynamic Client Registration Protocol (RFC7591)\n*   OAuth 2.0 Protected Resource Metadata (RFC9728)\n*   OAuth Client ID Metadata Documents (draft-ietf-oauth-client-id-metadata-document-00)\n\nRoles\n-----\n\nA protected _MCP server_ acts as an OAuth 2.1 resource server, capable of accepting and responding to protected resource requests using access tokens.An _MCP client_ acts as an OAuth 2.1 client, making protected resource requests on behalf of a resource owner.The _authorization server_ is responsible for interacting with the user (if necessary) and issuing access tokens for use at the MCP server. The implementation details of the authorization server are beyond the scope of this specification. It may be hosted with the resource server or a separate entity. The Authorization Server Discovery section specifies how an MCP server indicates the location of its corresponding authorization server to a client.\n\nOverview\n--------\n\n1.   Authorization servers **MUST** implement OAuth 2.1 with appropriate security measures for both confidential and public clients.\n2.   Authorization servers and MCP clients **SHOULD** support OAuth Client ID Metadata Documents (draft-ietf-oauth-client-id-metadata-document-00).\n3.   Authorization servers and MCP clients **MAY** support the OAuth 2.0 Dynamic Client Registration Protocol (RFC7591).\n4.   MCP servers **MUST** implement OAuth 2.0 Protected Resource Metadata (RFC9728). MCP clients **MUST** use OAuth 2.0 Protected Resource Metadata for authorization server discovery.\n5.   MCP authorization servers **MUST** provide at least one of the following discovery mechanisms:\n    *   OAuth 2.0 Authorization Server Metadata (RFC8414)\n    *   OpenID Connect Discovery 1.0\n\nMCP clients **MUST** support both discovery mechanisms to obtain the information required to interact with the authorization server.\n\nThis section describes the mechanisms by which MCP servers advertise their associated authorization servers to MCP clients, as well as the discovery process through which MCP clients can determine authorization server endpoints and supported capabilities.\n\n### Authorization Server Location\n\nMCP servers **MUST** implement the OAuth 2.0 Protected Resource Metadata (RFC9728) specification to indicate the locations of authorization servers. The Protected Resource Metadata document returned by the MCP server **MUST** include the `authorization_servers` field containing at least one authorization server.The specific use of `authorization_servers` is beyond the scope of this specification; implementers should consult OAuth 2.0 Protected Resource Metadata (RFC9728) for guidance on implementation details.Implementors should note that Protected Resource Metadata documents can define multiple authorization servers. The responsibility for selecting which authorization server to use lies with the MCP client, following the guidelines specified in RFC9728 Section 7.6 “Authorization Servers”.\n\n### Protected Resource Metadata Discovery Requirements\n\nMCP servers **MUST** implement one of the following discovery mechanisms to provide authorization server location information to MCP clients:\n\n1.   **WWW-Authenticate Header**: Include the resource metadata URL in the `WWW-Authenticate` HTTP header under `resource_metadata` when returning `401 Unauthorized` responses, as described in RFC9728 Section 5.1.\n2.   **Well-Known URI**: Serve metadata at a well-known URI as specified in RFC9728. This can be either:\n    *   At the path of the server’s MCP endpoint: `https://example.com/public/mcp` could host metadata at `https://example.com/.well-known/oauth-protected-resource/public/mcp`\n    *   At the root: `https://example.com/.well-known/oauth-protected-resource`\n\nMCP clients **MUST** support both discovery mechanisms and use the resource metadata URL from the parsed `WWW-Authenticate` headers when present; otherwise, they **MUST** fall back to constructing and requesting the well-known URIs in the order listed above.MCP servers **SHOULD** include a `scope` parameter in the `WWW-Authenticate` header as defined in RFC 6750 Section 3 to indicate the scopes required for accessing the resource. This provides clients with immediate guidance on the appropriate scopes to request during authorization, following the principle of least privilege and preventing clients from requesting excessive permissions.The scopes included in the `WWW-Authenticate` challenge **MAY** match `scopes_supported`, be a subset or superset of it, or an alternative collection that is neither a strict subset nor superset. Clients **MUST NOT** assume any particular set relationship between the challenged scope set and `scopes_supported`. Clients **MUST** treat the scopes provided in the challenge as authoritative for satisfying the current request. Servers **SHOULD** strive for consistency in how they construct scope sets but they are not required to surface every dynamically issued scope through `scopes_supported`.Example 401 response with scope guidance:\n\n```\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer resource_metadata=\"https://mcp.example.com/.well-known/oauth-protected-resource\",\n                         scope=\"files:read\"\n```\n\nMCP clients **MUST** be able to parse `WWW-Authenticate` headers and respond appropriately to `HTTP 401 Unauthorized` responses from the MCP server.If the `scope` parameter is absent, clients **SHOULD** apply the fallback behavior defined in the Scope Selection Strategy section.\n\n### Authorization Server Metadata Discovery\n\nTo handle different issuer URL formats and ensure interoperability with both OAuth 2.0 Authorization Server Metadata and OpenID Connect Discovery 1.0 specifications, MCP clients **MUST** attempt multiple well-known endpoints when discovering authorization server metadata.The discovery approach is based on RFC8414 Section 3.1 “Authorization Server Metadata Request” for OAuth 2.0 Authorization Server Metadata discovery and RFC8414 Section 5 “Compatibility Notes” for OpenID Connect Discovery 1.0 interoperability.For issuer URLs with path components (e.g., `https://auth.example.com/tenant1`), clients **MUST** try endpoints in the following priority order:\n\n1.   OAuth 2.0 Authorization Server Metadata with path insertion: `https://auth.example.com/.well-known/oauth-authorization-server/tenant1`\n2.   OpenID Connect Discovery 1.0 with path insertion: `https://auth.example.com/.well-known/openid-configuration/tenant1`\n3.   OpenID Connect Discovery 1.0 path appending: `https://auth.example.com/tenant1/.well-known/openid-configuration`\n\nFor issuer URLs without path components (e.g., `https://auth.example.com`), clients **MUST** try:\n\n1.   OAuth 2.0 Authorization Server Metadata: `https://auth.example.com/.well-known/oauth-authorization-server`\n2.   OpenID Connect Discovery 1.0: `https://auth.example.com/.well-known/openid-configuration`\n\n### Authorization Server Discovery Sequence Diagram\n\nThe following diagram outlines an example flow:\n\nClient Registration Approaches\n------------------------------\n\nMCP supports three client registration mechanisms. Choose based on your scenario:\n\n*   **Client ID Metadata Documents**: When client and server have no prior relationship (most common)\n*   **Pre-registration**: When client and server have an existing relationship\n*   **Dynamic Client Registration**: For backwards compatibility or specific requirements\n\nClients supporting all options **SHOULD** follow the following priority order:\n\n1.   Use pre-registered client information for the server if the client has it available\n2.   Use Client ID Metadata Documents if the Authorization Server indicates if the server supports it (via `client_id_metadata_document_supported` in OAuth Authorization Server Metadata)\n3.   Use Dynamic Client Registration as a fallback if the Authorization Server supports it (via `registration_endpoint` in OAuth Authorization Server Metadata)\n4.   Prompt the user to enter the client information if no other option is available\n\n### Client ID Metadata Documents\n\nMCP clients and authorization servers **SHOULD** support OAuth Client ID Metadata Documents as specified in OAuth Client ID Metadata Document. This approach enables clients to use HTTPS URLs as client identifiers, where the URL points to a JSON document containing client metadata. This addresses the common MCP scenario where servers and clients have no pre-existing relationship.\n\n#### Implementation Requirements\n\nMCP implementations supporting Client ID Metadata Documents **MUST** follow the requirements specified in OAuth Client ID Metadata Document. Key requirements include:**For MCP Clients:**\n\n*   Clients **MUST** host their metadata document at an HTTPS URL following RFC requirements\n*   The `client_id` URL **MUST** use the “https” scheme and contain a path component, e.g. `https://example.com/client.json`\n*   The metadata document **MUST** include at least the following properties: `client_id`, `client_name`, `redirect_uris`\n*   Clients **MUST** ensure the `client_id` value in the metadata matches the document URL exactly\n*   Clients **MAY** use `private_key_jwt` for client authentication (e.g., for requests to the token endpoint) with appropriate JWKS configuration as described in Section 6.2 of Client ID Metadata Document\n\n**For Authorization Servers:**\n\n*   **SHOULD** fetch metadata documents when encountering URL-formatted client_ids\n*   **MUST** validate that the fetched document’s `client_id` matches the URL exactly\n*   **SHOULD** cache metadata respecting HTTP cache headers\n*   **MUST** validate redirect URIs presented in an authorization request against those in the metadata document\n*   **MUST** validate the document structure is valid JSON and contains required fields\n*   **SHOULD** follow the security considerations in Section 6 of Client ID Metadata Document\n\n#### Example Metadata Document\n\n```\n{\n  \"client_id\": \"https://app.example.com/oauth/client-metadata.json\",\n  \"client_name\": \"Example MCP Client\",\n  \"client_uri\": \"https://app.example.com\",\n  \"logo_uri\": \"https://app.example.com/logo.png\",\n  \"redirect_uris\": [\n    \"http://127.0.0.1:3000/callback\",\n    \"http://localhost:3000/callback\"\n  ],\n  \"grant_types\": [\"authorization_code\"],\n  \"response_types\": [\"code\"],\n  \"token_endpoint_auth_method\": \"none\"\n}\n```\n\n#### Client ID Metadata Documents Flow\n\nThe following diagram illustrates the complete flow when using Client ID Metadata Documents:\n\n#### Discovery\n\nAuthorization servers advertise that they support clients using Client ID Metadata Documents by including the following property in their OAuth Authorization Server metadata:\n\n```\n{\n  \"client_id_metadata_document_supported\": true\n}\n```\n\nMCP clients **SHOULD** check for this capability and **MAY** fall back to Dynamic Client Registration or pre-registration if unavailable.\n\n### Preregistration\n\nMCP clients **SHOULD** support an option for static client credentials such as those supplied by a preregistration flow. This could be:\n\n1.   Hardcode a client ID (and, if applicable, client credentials) specifically for the MCP client to use when interacting with that authorization server, or\n2.   Present a UI to users that allows them to enter these details, after registering an OAuth client themselves (e.g., through a configuration interface hosted by the server).\n\n### Dynamic Client Registration\n\nMCP clients and authorization servers **MAY** support the OAuth 2.0 Dynamic Client Registration Protocol RFC7591 to allow MCP clients to obtain OAuth client IDs without user interaction. This option is included for backwards compatibility with earlier versions of the MCP authorization spec.\n\nScope Selection Strategy\n------------------------\n\nWhen implementing authorization flows, MCP clients **SHOULD** follow the principle of least privilege by requesting only the scopes necessary for their intended operations. During the initial authorization handshake, MCP clients **SHOULD** follow this priority order for scope selection:\n\n1.   **Use `scope` parameter** from the initial `WWW-Authenticate` header in the 401 response, if provided\n2.   **If `scope` is not available**, use all scopes defined in `scopes_supported` from the Protected Resource Metadata document, omitting the `scope` parameter if `scopes_supported` is undefined.\n\nThis approach accommodates the general-purpose nature of MCP clients, which typically lack domain-specific knowledge to make informed decisions about individual scope selection. Requesting all available scopes allows the authorization server and end-user to determine appropriate permissions during the consent process.This approach minimizes user friction while following the principle of least privilege. The `scopes_supported` field is intended to represent the minimal set of scopes necessary for basic functionality (see Scope Minimization), with additional scopes requested incrementally through the step-up authorization flow steps described in the Scope Challenge Handling section.\n\nAuthorization Flow Steps\n------------------------\n\nThe complete Authorization flow proceeds as follows:\n\nResource Parameter Implementation\n---------------------------------\n\nMCP clients **MUST** implement Resource Indicators for OAuth 2.0 as defined in RFC 8707 to explicitly specify the target resource for which the token is being requested. The `resource` parameter:\n\n1.   **MUST** be included in both authorization requests and token requests.\n2.   **MUST** identify the MCP server that the client intends to use the token with.\n3.   **MUST** use the canonical URI of the MCP server as defined in RFC 8707 Section 2.\n\n### Canonical Server URI\n\nFor the purposes of this specification, the canonical URI of an MCP server is defined as the resource identifier as specified in RFC 8707 Section 2 and aligns with the `resource` parameter in RFC 9728.MCP clients **SHOULD** provide the most specific URI that they can for the MCP server they intend to access, following the guidance in RFC 8707. While the canonical form uses lowercase scheme and host components, implementations **SHOULD** accept uppercase scheme and host components for robustness and interoperability.Examples of valid canonical URIs:\n\n*   `https://mcp.example.com/mcp`\n*   `https://mcp.example.com`\n*   `https://mcp.example.com:8443`\n*   `https://mcp.example.com/server/mcp` (when path component is necessary to identify individual MCP server)\n\nExamples of invalid canonical URIs:\n\n*   `mcp.example.com` (missing scheme)\n*   `https://mcp.example.com#fragment` (contains fragment)\n\n\n"},"metadata":{"arguments":"{\"link_id\":5}","display_result":"","duration":"4s","id":"call_D1dUomobAf","is_error":false,"mcp_server":{"name":"mcp-server"},"name":"click","result":"【5†Authorization†https://modelcontextprotocol.io/specification/draft/basic/authorization】\nTitle: Authorization - Model Context Protocol\n\nURL Source: https://modelcontextprotocol.io/specification/draft/basic/authorization\n\nMarkdown Content:\nIntroduction\n------------\n\n### Purpose and Scope\n\nThe Model Context Protocol provides authorization capabilities at the transport level, enabling MCP clients to make requests to restricted MCP servers on behalf of resource owners. This specification defines the authorization flow for HTTP-based transports.\n\n### Protocol Requirements\n\nAuthorization is **OPTIONAL** for MCP implementations. When supported:\n\n*   Implementations using an HTTP-based transport **SHOULD** conform to this specification.\n*   Implementations using an STDIO transport **SHOULD NOT** follow this specification, and instead retrieve credentials from the environment.\n*   Implementations using alternative transports **MUST** follow established security best practices for their protocol.\n\n### Standards Compliance\n\nThis authorization mechanism is based on established specifications listed below, but implements a selected subset of their features to ensure security and interoperability while maintaining simplicity:\n\n*   OAuth 2.1 IETF DRAFT (draft-ietf-oauth-v2-1-13)\n*   OAuth 2.0 Authorization Server Metadata (RFC8414)\n*   OAuth 2.0 Dynamic Client Registration Protocol (RFC7591)\n*   OAuth 2.0 Protected Resource Metadata (RFC9728)\n*   OAuth Client ID Metadata Documents (draft-ietf-oauth-client-id-metadata-document-00)\n\nRoles\n-----\n\nA protected _MCP server_ acts as an OAuth 2.1 resource server, capable of accepting and responding to protected resource requests using access tokens.An _MCP client_ acts as an OAuth 2.1 client, making protected resource requests on behalf of a resource owner.The _authorization server_ is responsible for interacting with the user (if necessary) and issuing access tokens for use at the MCP server. The implementation details of the authorization server are beyond the scope of this specification. It may be hosted with the resource server or a separate entity. The Authorization Server Discovery section specifies how an MCP server indicates the location of its corresponding authorization server to a client.\n\nOverview\n--------\n\n1.   Authorization servers **MUST** implement OAuth 2.1 with appropriate security measures for both confidential and public clients.\n2.   Authorization servers and MCP clients **SHOULD** support OAuth Client ID Metadata Documents (draft-ietf-oauth-client-id-metadata-document-00).\n3.   Authorization servers and MCP clients **MAY** support the OAuth 2.0 Dynamic Client Registration Protocol (RFC7591).\n4.   MCP servers **MUST** implement OAuth 2.0 Protected Resource Metadata (RFC9728). MCP clients **MUST** use OAuth 2.0 Protected Resource Metadata for authorization server discovery.\n5.   MCP authorization servers **MUST** provide at least one of the following discovery mechanisms:\n    *   OAuth 2.0 Authorization Server Metadata (RFC8414)\n    *   OpenID Connect Discovery 1.0\n\nMCP clients **MUST** support both discovery mechanisms to obtain the information required to interact with the authorization server.\n\nThis section describes the mechanisms by which MCP servers advertise their associated authorization servers to MCP clients, as well as the discovery process through which MCP clients can determine authorization server endpoints and supported capabilities.\n\n### Authorization Server Location\n\nMCP servers **MUST** implement the OAuth 2.0 Protected Resource Metadata (RFC9728) specification to indicate the locations of authorization servers. The Protected Resource Metadata document returned by the MCP server **MUST** include the `authorization_servers` field containing at least one authorization server.The specific use of `authorization_servers` is beyond the scope of this specification; implementers should consult OAuth 2.0 Protected Resource Metadata (RFC9728) for guidance on implementation details.Implementors should note that Protected Resource Metadata documents can define multiple authorization servers. The responsibility for selecting which authorization server to use lies with the MCP client, following the guidelines specified in RFC9728 Section 7.6 “Authorization Servers”.\n\n### Protected Resource Metadata Discovery Requirements\n\nMCP servers **MUST** implement one of the following discovery mechanisms to provide authorization server location information to MCP clients:\n\n1.   **WWW-Authenticate Header**: Include the resource metadata URL in the `WWW-Authenticate` HTTP header under `resource_metadata` when returning `401 Unauthorized` responses, as described in RFC9728 Section 5.1.\n2.   **Well-Known URI**: Serve metadata at a well-known URI as specified in RFC9728. This can be either:\n    *   At the path of the server’s MCP endpoint: `https://example.com/public/mcp` could host metadata at `https://example.com/.well-known/oauth-protected-resource/public/mcp`\n    *   At the root: `https://example.com/.well-known/oauth-protected-resource`\n\nMCP clients **MUST** support both discovery mechanisms and use the resource metadata URL from the parsed `WWW-Authenticate` headers when present; otherwise, they **MUST** fall back to constructing and requesting the well-known URIs in the order listed above.MCP servers **SHOULD** include a `scope` parameter in the `WWW-Authenticate` header as defined in RFC 6750 Section 3 to indicate the scopes required for accessing the resource. This provides clients with immediate guidance on the appropriate scopes to request during authorization, following the principle of least privilege and preventing clients from requesting excessive permissions.The scopes included in the `WWW-Authenticate` challenge **MAY** match `scopes_supported`, be a subset or superset of it, or an alternative collection that is neither a strict subset nor superset. Clients **MUST NOT** assume any particular set relationship between the challenged scope set and `scopes_supported`. Clients **MUST** treat the scopes provided in the challenge as authoritative for satisfying the current request. Servers **SHOULD** strive for consistency in how they construct scope sets but they are not required to surface every dynamically issued scope through `scopes_supported`.Example 401 response with scope guidance:\n\n```\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer resource_metadata=\"https://mcp.example.com/.well-known/oauth-protected-resource\",\n                         scope=\"files:read\"\n```\n\nMCP clients **MUST** be able to parse `WWW-Authenticate` headers and respond appropriately to `HTTP 401 Unauthorized` responses from the MCP server.If the `scope` parameter is absent, clients **SHOULD** apply the fallback behavior defined in the Scope Selection Strategy section.\n\n### Authorization Server Metadata Discovery\n\nTo handle different issuer URL formats and ensure interoperability with both OAuth 2.0 Authorization Server Metadata and OpenID Connect Discovery 1.0 specifications, MCP clients **MUST** attempt multiple well-known endpoints when discovering authorization server metadata.The discovery approach is based on RFC8414 Section 3.1 “Authorization Server Metadata Request” for OAuth 2.0 Authorization Server Metadata discovery and RFC8414 Section 5 “Compatibility Notes” for OpenID Connect Discovery 1.0 interoperability.For issuer URLs with path components (e.g., `https://auth.example.com/tenant1`), clients **MUST** try endpoints in the following priority order:\n\n1.   OAuth 2.0 Authorization Server Metadata with path insertion: `https://auth.example.com/.well-known/oauth-authorization-server/tenant1`\n2.   OpenID Connect Discovery 1.0 with path insertion: `https://auth.example.com/.well-known/openid-configuration/tenant1`\n3.   OpenID Connect Discovery 1.0 path appending: `https://auth.example.com/tenant1/.well-known/openid-configuration`\n\nFor issuer URLs without path components (e.g., `https://auth.example.com`), clients **MUST** try:\n\n1.   OAuth 2.0 Authorization Server Metadata: `https://auth.example.com/.well-known/oauth-authorization-server`\n2.   OpenID Connect Discovery 1.0: `https://auth.example.com/.well-known/openid-configuration`\n\n### Authorization Server Discovery Sequence Diagram\n\nThe following diagram outlines an example flow:\n\nClient Registration Approaches\n------------------------------\n\nMCP supports three client registration mechanisms. Choose based on your scenario:\n\n*   **Client ID Metadata Documents**: When client and server have no prior relationship (most common)\n*   **Pre-registration**: When client and server have an existing relationship\n*   **Dynamic Client Registration**: For backwards compatibility or specific requirements\n\nClients supporting all options **SHOULD** follow the following priority order:\n\n1.   Use pre-registered client information for the server if the client has it available\n2.   Use Client ID Metadata Documents if the Authorization Server indicates if the server supports it (via `client_id_metadata_document_supported` in OAuth Authorization Server Metadata)\n3.   Use Dynamic Client Registration as a fallback if the Authorization Server supports it (via `registration_endpoint` in OAuth Authorization Server Metadata)\n4.   Prompt the user to enter the client information if no other option is available\n\n### Client ID Metadata Documents\n\nMCP clients and authorization servers **SHOULD** support OAuth Client ID Metadata Documents as specified in OAuth Client ID Metadata Document. This approach enables clients to use HTTPS URLs as client identifiers, where the URL points to a JSON document containing client metadata. This addresses the common MCP scenario where servers and clients have no pre-existing relationship.\n\n#### Implementation Requirements\n\nMCP implementations supporting Client ID Metadata Documents **MUST** follow the requirements specified in OAuth Client ID Metadata Document. Key requirements include:**For MCP Clients:**\n\n*   Clients **MUST** host their metadata document at an HTTPS URL following RFC requirements\n*   The `client_id` URL **MUST** use the “https” scheme and contain a path component, e.g. `https://example.com/client.json`\n*   The metadata document **MUST** include at least the following properties: `client_id`, `client_name`, `redirect_uris`\n*   Clients **MUST** ensure the `client_id` value in the metadata matches the document URL exactly\n*   Clients **MAY** use `private_key_jwt` for client authentication (e.g., for requests to the token endpoint) with appropriate JWKS configuration as described in Section 6.2 of Client ID Metadata Document\n\n**For Authorization Servers:**\n\n*   **SHOULD** fetch metadata documents when encountering URL-formatted client_ids\n*   **MUST** validate that the fetched document’s `client_id` matches the URL exactly\n*   **SHOULD** cache metadata respecting HTTP cache headers\n*   **MUST** validate redirect URIs presented in an authorization request against those in the metadata document\n*   **MUST** validate the document structure is valid JSON and contains required fields\n*   **SHOULD** follow the security considerations in Section 6 of Client ID Metadata Document\n\n#### Example Metadata Document\n\n```\n{\n  \"client_id\": \"https://app.example.com/oauth/client-metadata.json\",\n  \"client_name\": \"Example MCP Client\",\n  \"client_uri\": \"https://app.example.com\",\n  \"logo_uri\": \"https://app.example.com/logo.png\",\n  \"redirect_uris\": [\n    \"http://127.0.0.1:3000/callback\",\n    \"http://localhost:3000/callback\"\n  ],\n  \"grant_types\": [\"authorization_code\"],\n  \"response_types\": [\"code\"],\n  \"token_endpoint_auth_method\": \"none\"\n}\n```\n\n#### Client ID Metadata Documents Flow\n\nThe following diagram illustrates the complete flow when using Client ID Metadata Documents:\n\n#### Discovery\n\nAuthorization servers advertise that they support clients using Client ID Metadata Documents by including the following property in their OAuth Authorization Server metadata:\n\n```\n{\n  \"client_id_metadata_document_supported\": true\n}\n```\n\nMCP clients **SHOULD** check for this capability and **MAY** fall back to Dynamic Client Registration or pre-registration if unavailable.\n\n### Preregistration\n\nMCP clients **SHOULD** support an option for static client credentials such as those supplied by a preregistration flow. This could be:\n\n1.   Hardcode a client ID (and, if applicable, client credentials) specifically for the MCP client to use when interacting with that authorization server, or\n2.   Present a UI to users that allows them to enter these details, after registering an OAuth client themselves (e.g., through a configuration interface hosted by the server).\n\n### Dynamic Client Registration\n\nMCP clients and authorization servers **MAY** support the OAuth 2.0 Dynamic Client Registration Protocol RFC7591 to allow MCP clients to obtain OAuth client IDs without user interaction. This option is included for backwards compatibility with earlier versions of the MCP authorization spec.\n\nScope Selection Strategy\n------------------------\n\nWhen implementing authorization flows, MCP clients **SHOULD** follow the principle of least privilege by requesting only the scopes necessary for their intended operations. During the initial authorization handshake, MCP clients **SHOULD** follow this priority order for scope selection:\n\n1.   **Use `scope` parameter** from the initial `WWW-Authenticate` header in the 401 response, if provided\n2.   **If `scope` is not available**, use all scopes defined in `scopes_supported` from the Protected Resource Metadata document, omitting the `scope` parameter if `scopes_supported` is undefined.\n\nThis approach accommodates the general-purpose nature of MCP clients, which typically lack domain-specific knowledge to make informed decisions about individual scope selection. Requesting all available scopes allows the authorization server and end-user to determine appropriate permissions during the consent process.This approach minimizes user friction while following the principle of least privilege. The `scopes_supported` field is intended to represent the minimal set of scopes necessary for basic functionality (see Scope Minimization), with additional scopes requested incrementally through the step-up authorization flow steps described in the Scope Challenge Handling section.\n\nAuthorization Flow Steps\n------------------------\n\nThe complete Authorization flow proceeds as follows:\n\nResource Parameter Implementation\n---------------------------------\n\nMCP clients **MUST** implement Resource Indicators for OAuth 2.0 as defined in RFC 8707 to explicitly specify the target resource for which the token is being requested. The `resource` parameter:\n\n1.   **MUST** be included in both authorization requests and token requests.\n2.   **MUST** identify the MCP server that the client intends to use the token with.\n3.   **MUST** use the canonical URI of the MCP server as defined in RFC 8707 Section 2.\n\n### Canonical Server URI\n\nFor the purposes of this specification, the canonical URI of an MCP server is defined as the resource identifier as specified in RFC 8707 Section 2 and aligns with the `resource` parameter in RFC 9728.MCP clients **SHOULD** provide the most specific URI that they can for the MCP server they intend to access, following the guidance in RFC 8707. While the canonical form uses lowercase scheme and host components, implementations **SHOULD** accept uppercase scheme and host components for robustness and interoperability.Examples of valid canonical URIs:\n\n*   `https://mcp.example.com/mcp`\n*   `https://mcp.example.com`\n*   `https://mcp.example.com:8443`\n*   `https://mcp.example.com/server/mcp` (when path component is necessary to identify individual MCP server)\n\nExamples of invalid canonical URIs:\n\n*   `mcp.example.com` (missing scheme)\n*   `https://mcp.example.com#fragment` (contains fragment)\n\n\n","status":"completed"}},"type":"mcp"}</glm_block>


<details type="reasoning" done="true" duration="4" view="" last_tool_call_name="click">
> MCPの認証に関する仕様が詳細に記述されています。認証はオプションですが、サポートする場合はOAuth 2.1に基づくことが求められています。また、クライアントIDメタデータドキュメントやダイナミッククライアント登録がサポートされています。
> 
> 次に、MCPサーバーの実装に関する情報を確認します。特に、ツールの安全性やリソースの取り扱いについてです。
</details>

<glm_block view="" tool_call_name="click">{"data":{"browser":{"url":"https://modelcontextprotocol.io/specification/2025-06-18/server/tools","title":"Tools","content":"【6†Tools†https://modelcontextprotocol.io/specification/2025-06-18/server/tools】\nTitle: Tools - Model Context Protocol\n\nURL Source: https://modelcontextprotocol.io/specification/2025-06-18/server/tools\n\nMarkdown Content:\nThe Model Context Protocol (MCP) allows servers to expose tools that can be invoked by language models. Tools enable models to interact with external systems, such as querying databases, calling APIs, or performing computations. Each tool is uniquely identified by a name and includes metadata describing its schema.\n\nUser Interaction Model\n----------------------\n\nTools in MCP are designed to be **model-controlled**, meaning that the language model can discover and invoke tools automatically based on its contextual understanding and the user’s prompts.However, implementations are free to expose tools through any interface pattern that suits their needs—the protocol itself does not mandate any specific user interaction model.\n\nCapabilities\n------------\n\nServers that support tools **MUST** declare the `tools` capability:\n\n```\n{\n  \"capabilities\": {\n    \"tools\": {\n      \"listChanged\": true\n    }\n  }\n}\n```\n\n`listChanged` indicates whether the server will emit notifications when the list of available tools changes.\n\nProtocol Messages\n-----------------\n\n### Listing Tools\n\nTo discover available tools, clients send a `tools/list` request. This operation supports pagination.**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tools/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"tools\": [\n      {\n        \"name\": \"get_weather\",\n        \"title\": \"Weather Information Provider\",\n        \"description\": \"Get current weather information for a location\",\n        \"inputSchema\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"location\": {\n              \"type\": \"string\",\n              \"description\": \"City name or zip code\"\n            }\n          },\n          \"required\": [\"location\"]\n        }\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n### Calling Tools\n\nTo invoke a tool, clients send a `tools/call` request:**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"get_weather\",\n    \"arguments\": {\n      \"location\": \"New York\"\n    }\n  }\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Current weather in New York:\\nTemperature: 72°F\\nConditions: Partly cloudy\"\n      }\n    ],\n    \"isError\": false\n  }\n}\n```\n\n### List Changed Notification\n\nWhen the list of available tools changes, servers that declared the `listChanged` capability **SHOULD** send a notification:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/tools/list_changed\"\n}\n```\n\nMessage Flow\n------------\n\nData Types\n----------\n\n### Tool\n\nA tool definition includes:\n\n*   `name`: Unique identifier for the tool\n*   `title`: Optional human-readable name of the tool for display purposes.\n*   `description`: Human-readable description of functionality\n*   `inputSchema`: JSON Schema defining expected parameters\n*   `outputSchema`: Optional JSON Schema defining expected output structure\n*   `annotations`: optional properties describing tool behavior\n\n### Tool Result\n\nTool results may contain **structured** or **unstructured** content.**Unstructured** content is returned in the `content` field of a result, and can contain multiple content items of different types:\n\n#### Text Content\n\n```\n{\n  \"type\": \"text\",\n  \"text\": \"Tool result text\"\n}\n```\n\n#### Image Content\n\n```\n{\n  \"type\": \"image\",\n  \"data\": \"base64-encoded-data\",\n  \"mimeType\": \"image/png\"\n  \"annotations\": {\n    \"audience\": [\"user\"],\n    \"priority\": 0.9\n  }\n\n}\n```\n\nThis example demonstrates the use of an optional Annotation.\n\n#### Audio Content\n\n```\n{\n  \"type\": \"audio\",\n  \"data\": \"base64-encoded-audio-data\",\n  \"mimeType\": \"audio/wav\"\n}\n```\n\n#### Resource Links\n\nA tool **MAY** return links to Resources, to provide additional context or data. In this case, the tool will return a URI that can be subscribed to or fetched by the client:\n\n```\n{\n  \"type\": \"resource_link\",\n  \"uri\": \"file:///project/src/main.rs\",\n  \"name\": \"main.rs\",\n  \"description\": \"Primary application entry point\",\n  \"mimeType\": \"text/x-rust\",\n  \"annotations\": {\n    \"audience\": [\"assistant\"],\n    \"priority\": 0.9\n  }\n}\n```\n\nResource links support the same Resource annotations as regular resources to help clients understand how to use them.\n\n#### Embedded Resources\n\nResources**MAY** be embedded to provide additional context or data using a suitable URI scheme. Servers that use embedded resources **SHOULD** implement the `resources` capability:\n\n```\n{\n  \"type\": \"resource\",\n  \"resource\": {\n    \"uri\": \"file:///project/src/main.rs\",\n    \"mimeType\": \"text/x-rust\",\n    \"text\": \"fn main() {\\n    println!(\\\"Hello world!\\\");\\n}\",\n    \"annotations\": {\n      \"audience\": [\"user\", \"assistant\"],\n      \"priority\": 0.7,\n      \"lastModified\": \"2025-05-03T14:30:00Z\"\n    }\n  }\n}\n```\n\nEmbedded resources support the same Resource annotations as regular resources to help clients understand how to use them.\n\n#### Structured Content\n\n**Structured** content is returned as a JSON object in the `structuredContent` field of a result.For backwards compatibility, a tool that returns structured content SHOULD also return the serialized JSON in a TextContent block.\n\n#### Output Schema\n\nTools may also provide an output schema for validation of structured results. If an output schema is provided:\n\n*   Servers **MUST** provide structured results that conform to this schema.\n*   Clients **SHOULD** validate structured results against this schema.\n\nExample tool with output schema:\n\n```\n{\n  \"name\": \"get_weather_data\",\n  \"title\": \"Weather Data Retriever\",\n  \"description\": \"Get current weather data for a location\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"location\": {\n        \"type\": \"string\",\n        \"description\": \"City name or zip code\"\n      }\n    },\n    \"required\": [\"location\"]\n  },\n  \"outputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"temperature\": {\n        \"type\": \"number\",\n        \"description\": \"Temperature in celsius\"\n      },\n      \"conditions\": {\n        \"type\": \"string\",\n        \"description\": \"Weather conditions description\"\n      },\n      \"humidity\": {\n        \"type\": \"number\",\n        \"description\": \"Humidity percentage\"\n      }\n    },\n    \"required\": [\"temperature\", \"conditions\", \"humidity\"]\n  }\n}\n```\n\nExample valid response for this tool:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 5,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"{\\\"temperature\\\": 22.5, \\\"conditions\\\": \\\"Partly cloudy\\\", \\\"humidity\\\": 65}\"\n      }\n    ],\n    \"structuredContent\": {\n      \"temperature\": 22.5,\n      \"conditions\": \"Partly cloudy\",\n      \"humidity\": 65\n    }\n  }\n}\n```\n\nProviding an output schema helps clients and LLMs understand and properly handle structured tool outputs by:\n\n*   Enabling strict schema validation of responses\n*   Providing type information for better integration with programming languages\n*   Guiding clients and LLMs to properly parse and utilize the returned data\n*   Supporting better documentation and developer experience\n\nError Handling\n--------------\n\nTools use two error reporting mechanisms:\n\n1.   **Protocol Errors**: Standard JSON-RPC errors for issues like:\n    *   Unknown tools\n    *   Invalid arguments\n    *   Server errors\n\n2.   **Tool Execution Errors**: Reported in tool results with `isError: true`:\n    *   API failures\n    *   Invalid input data\n    *   Business logic errors\n\nExample protocol error:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Unknown tool: invalid_tool_name\"\n  }\n}\n```\n\nExample tool execution error:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 4,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Failed to fetch weather data: API rate limit exceeded\"\n      }\n    ],\n    \"isError\": true\n  }\n}\n```\n\nSecurity Considerations\n-----------------------\n\n1.   Servers **MUST**:\n    *   Validate all tool inputs\n    *   Implement proper access controls\n    *   Rate limit tool invocations\n    *   Sanitize tool outputs\n\n2.   Clients **SHOULD**:\n    *   Prompt for user confirmation on sensitive operations\n    *   Show tool inputs to the user before calling the server, to avoid malicious or accidental data exfiltration\n    *   Validate tool results before passing to LLM\n    *   Implement timeouts for tool calls\n    *   Log tool usage for audit purposes\n\n"},"metadata":{"arguments":"{\"link_id\":6}","display_result":"","duration":"10s","id":"call_BgQxH09Kua","is_error":false,"mcp_server":{"name":"mcp-server"},"name":"click","result":"【6†Tools†https://modelcontextprotocol.io/specification/2025-06-18/server/tools】\nTitle: Tools - Model Context Protocol\n\nURL Source: https://modelcontextprotocol.io/specification/2025-06-18/server/tools\n\nMarkdown Content:\nThe Model Context Protocol (MCP) allows servers to expose tools that can be invoked by language models. Tools enable models to interact with external systems, such as querying databases, calling APIs, or performing computations. Each tool is uniquely identified by a name and includes metadata describing its schema.\n\nUser Interaction Model\n----------------------\n\nTools in MCP are designed to be **model-controlled**, meaning that the language model can discover and invoke tools automatically based on its contextual understanding and the user’s prompts.However, implementations are free to expose tools through any interface pattern that suits their needs—the protocol itself does not mandate any specific user interaction model.\n\nCapabilities\n------------\n\nServers that support tools **MUST** declare the `tools` capability:\n\n```\n{\n  \"capabilities\": {\n    \"tools\": {\n      \"listChanged\": true\n    }\n  }\n}\n```\n\n`listChanged` indicates whether the server will emit notifications when the list of available tools changes.\n\nProtocol Messages\n-----------------\n\n### Listing Tools\n\nTo discover available tools, clients send a `tools/list` request. This operation supports pagination.**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tools/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"tools\": [\n      {\n        \"name\": \"get_weather\",\n        \"title\": \"Weather Information Provider\",\n        \"description\": \"Get current weather information for a location\",\n        \"inputSchema\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"location\": {\n              \"type\": \"string\",\n              \"description\": \"City name or zip code\"\n            }\n          },\n          \"required\": [\"location\"]\n        }\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n### Calling Tools\n\nTo invoke a tool, clients send a `tools/call` request:**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"get_weather\",\n    \"arguments\": {\n      \"location\": \"New York\"\n    }\n  }\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Current weather in New York:\\nTemperature: 72°F\\nConditions: Partly cloudy\"\n      }\n    ],\n    \"isError\": false\n  }\n}\n```\n\n### List Changed Notification\n\nWhen the list of available tools changes, servers that declared the `listChanged` capability **SHOULD** send a notification:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/tools/list_changed\"\n}\n```\n\nMessage Flow\n------------\n\nData Types\n----------\n\n### Tool\n\nA tool definition includes:\n\n*   `name`: Unique identifier for the tool\n*   `title`: Optional human-readable name of the tool for display purposes.\n*   `description`: Human-readable description of functionality\n*   `inputSchema`: JSON Schema defining expected parameters\n*   `outputSchema`: Optional JSON Schema defining expected output structure\n*   `annotations`: optional properties describing tool behavior\n\n### Tool Result\n\nTool results may contain **structured** or **unstructured** content.**Unstructured** content is returned in the `content` field of a result, and can contain multiple content items of different types:\n\n#### Text Content\n\n```\n{\n  \"type\": \"text\",\n  \"text\": \"Tool result text\"\n}\n```\n\n#### Image Content\n\n```\n{\n  \"type\": \"image\",\n  \"data\": \"base64-encoded-data\",\n  \"mimeType\": \"image/png\"\n  \"annotations\": {\n    \"audience\": [\"user\"],\n    \"priority\": 0.9\n  }\n\n}\n```\n\nThis example demonstrates the use of an optional Annotation.\n\n#### Audio Content\n\n```\n{\n  \"type\": \"audio\",\n  \"data\": \"base64-encoded-audio-data\",\n  \"mimeType\": \"audio/wav\"\n}\n```\n\n#### Resource Links\n\nA tool **MAY** return links to Resources, to provide additional context or data. In this case, the tool will return a URI that can be subscribed to or fetched by the client:\n\n```\n{\n  \"type\": \"resource_link\",\n  \"uri\": \"file:///project/src/main.rs\",\n  \"name\": \"main.rs\",\n  \"description\": \"Primary application entry point\",\n  \"mimeType\": \"text/x-rust\",\n  \"annotations\": {\n    \"audience\": [\"assistant\"],\n    \"priority\": 0.9\n  }\n}\n```\n\nResource links support the same Resource annotations as regular resources to help clients understand how to use them.\n\n#### Embedded Resources\n\nResources**MAY** be embedded to provide additional context or data using a suitable URI scheme. Servers that use embedded resources **SHOULD** implement the `resources` capability:\n\n```\n{\n  \"type\": \"resource\",\n  \"resource\": {\n    \"uri\": \"file:///project/src/main.rs\",\n    \"mimeType\": \"text/x-rust\",\n    \"text\": \"fn main() {\\n    println!(\\\"Hello world!\\\");\\n}\",\n    \"annotations\": {\n      \"audience\": [\"user\", \"assistant\"],\n      \"priority\": 0.7,\n      \"lastModified\": \"2025-05-03T14:30:00Z\"\n    }\n  }\n}\n```\n\nEmbedded resources support the same Resource annotations as regular resources to help clients understand how to use them.\n\n#### Structured Content\n\n**Structured** content is returned as a JSON object in the `structuredContent` field of a result.For backwards compatibility, a tool that returns structured content SHOULD also return the serialized JSON in a TextContent block.\n\n#### Output Schema\n\nTools may also provide an output schema for validation of structured results. If an output schema is provided:\n\n*   Servers **MUST** provide structured results that conform to this schema.\n*   Clients **SHOULD** validate structured results against this schema.\n\nExample tool with output schema:\n\n```\n{\n  \"name\": \"get_weather_data\",\n  \"title\": \"Weather Data Retriever\",\n  \"description\": \"Get current weather data for a location\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"location\": {\n        \"type\": \"string\",\n        \"description\": \"City name or zip code\"\n      }\n    },\n    \"required\": [\"location\"]\n  },\n  \"outputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"temperature\": {\n        \"type\": \"number\",\n        \"description\": \"Temperature in celsius\"\n      },\n      \"conditions\": {\n        \"type\": \"string\",\n        \"description\": \"Weather conditions description\"\n      },\n      \"humidity\": {\n        \"type\": \"number\",\n        \"description\": \"Humidity percentage\"\n      }\n    },\n    \"required\": [\"temperature\", \"conditions\", \"humidity\"]\n  }\n}\n```\n\nExample valid response for this tool:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 5,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"{\\\"temperature\\\": 22.5, \\\"conditions\\\": \\\"Partly cloudy\\\", \\\"humidity\\\": 65}\"\n      }\n    ],\n    \"structuredContent\": {\n      \"temperature\": 22.5,\n      \"conditions\": \"Partly cloudy\",\n      \"humidity\": 65\n    }\n  }\n}\n```\n\nProviding an output schema helps clients and LLMs understand and properly handle structured tool outputs by:\n\n*   Enabling strict schema validation of responses\n*   Providing type information for better integration with programming languages\n*   Guiding clients and LLMs to properly parse and utilize the returned data\n*   Supporting better documentation and developer experience\n\nError Handling\n--------------\n\nTools use two error reporting mechanisms:\n\n1.   **Protocol Errors**: Standard JSON-RPC errors for issues like:\n    *   Unknown tools\n    *   Invalid arguments\n    *   Server errors\n\n2.   **Tool Execution Errors**: Reported in tool results with `isError: true`:\n    *   API failures\n    *   Invalid input data\n    *   Business logic errors\n\nExample protocol error:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Unknown tool: invalid_tool_name\"\n  }\n}\n```\n\nExample tool execution error:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 4,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Failed to fetch weather data: API rate limit exceeded\"\n      }\n    ],\n    \"isError\": true\n  }\n}\n```\n\nSecurity Considerations\n-----------------------\n\n1.   Servers **MUST**:\n    *   Validate all tool inputs\n    *   Implement proper access controls\n    *   Rate limit tool invocations\n    *   Sanitize tool outputs\n\n2.   Clients **SHOULD**:\n    *   Prompt for user confirmation on sensitive operations\n    *   Show tool inputs to the user before calling the server, to avoid malicious or accidental data exfiltration\n    *   Validate tool results before passing to LLM\n    *   Implement timeouts for tool calls\n    *   Log tool usage for audit purposes\n\n","status":"completed"}},"type":"mcp"}</glm_block>


<details type="reasoning" done="true" duration="2" view="" last_tool_call_name="click">
> MCPのツールに関する仕様が理解できました。ツールは言語モデルによって自動的に発見および呼び出され、外部システムとの対話を可能にします。また、ツールの呼び出しには適切なバリデーション、アクセス制御、レート制限、出力のサニタイズが求められます。
> 
> 次に、リソースに関する仕様を確認します。
</details>

<glm_block view="" tool_call_name="click">{"data":{"browser":{"url":"https://modelcontextprotocol.io/specification/2025-06-18/server/resources","title":"Resources","content":"【9†Resources†https://modelcontextprotocol.io/specification/2025-06-18/server/resources】\nTitle: Resources - Model Context Protocol\n\nURL Source: https://modelcontextprotocol.io/specification/2025-06-18/server/resources\n\nMarkdown Content:\nThe Model Context Protocol (MCP) provides a standardized way for servers to expose resources to clients. Resources allow servers to share data that provides context to language models, such as files, database schemas, or application-specific information. Each resource is uniquely identified by a URI.\n\nUser Interaction Model\n----------------------\n\nResources in MCP are designed to be **application-driven**, with host applications determining how to incorporate context based on their needs.For example, applications could:\n\n*   Expose resources through UI elements for explicit selection, in a tree or list view\n*   Allow the user to search through and filter available resources\n*   Implement automatic context inclusion, based on heuristics or the AI model’s selection\n\nHowever, implementations are free to expose resources through any interface pattern that suits their needs—the protocol itself does not mandate any specific user interaction model.\n\nCapabilities\n------------\n\nServers that support resources **MUST** declare the `resources` capability:\n\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"subscribe\": true,\n      \"listChanged\": true\n    }\n  }\n}\n```\n\nThe capability supports two optional features:\n\n*   `subscribe`: whether the client can subscribe to be notified of changes to individual resources.\n*   `listChanged`: whether the server will emit notifications when the list of available resources changes.\n\nBoth `subscribe` and `listChanged` are optional—servers can support neither, either, or both:\n\n```\n{\n  \"capabilities\": {\n    \"resources\": {} // Neither feature supported\n  }\n}\n```\n\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"subscribe\": true // Only subscriptions supported\n    }\n  }\n}\n```\n\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"listChanged\": true // Only list change notifications supported\n    }\n  }\n}\n```\n\nProtocol Messages\n-----------------\n\n### Listing Resources\n\nTo discover available resources, clients send a `resources/list` request. This operation supports pagination.**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"resources/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"resources\": [\n      {\n        \"uri\": \"file:///project/src/main.rs\",\n        \"name\": \"main.rs\",\n        \"title\": \"Rust Software Application Main File\",\n        \"description\": \"Primary application entry point\",\n        \"mimeType\": \"text/x-rust\"\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n### Reading Resources\n\nTo retrieve resource contents, clients send a `resources/read` request:**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"resources/read\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"contents\": [\n      {\n        \"uri\": \"file:///project/src/main.rs\",\n        \"mimeType\": \"text/x-rust\",\n        \"text\": \"fn main() {\\n    println!(\\\"Hello world!\\\");\\n}\"\n      }\n    ]\n  }\n}\n```\n\n### Resource Templates\n\nResource templates allow servers to expose parameterized resources using URI templates. Arguments may be auto-completed through the completion API.**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"method\": \"resources/templates/list\"\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"result\": {\n    \"resourceTemplates\": [\n      {\n        \"uriTemplate\": \"file:///{path}\",\n        \"name\": \"Project Files\",\n        \"title\": \"📁 Project Files\",\n        \"description\": \"Access files in the project directory\",\n        \"mimeType\": \"application/octet-stream\"\n      }\n    ]\n  }\n}\n```\n\n### List Changed Notification\n\nWhen the list of available resources changes, servers that declared the `listChanged` capability **SHOULD** send a notification:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/resources/list_changed\"\n}\n```\n\n### Subscriptions\n\nThe protocol supports optional subscriptions to resource changes. Clients can subscribe to specific resources and receive notifications when they change:**Subscribe Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 4,\n  \"method\": \"resources/subscribe\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\n**Update Notification:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/resources/updated\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\nMessage Flow\n------------\n\nData Types\n----------\n\n### Resource\n\nA resource definition includes:\n\n*   `uri`: Unique identifier for the resource\n*   `name`: The name of the resource.\n*   `title`: Optional human-readable name of the resource for display purposes.\n*   `description`: Optional description\n*   `mimeType`: Optional MIME type\n*   `size`: Optional size in bytes\n\n### Resource Contents\n\nResources can contain either text or binary data:\n\n#### Text Content\n\n```\n{\n  \"uri\": \"file:///example.txt\",\n  \"mimeType\": \"text/plain\",\n  \"text\": \"Resource content\"\n}\n```\n\n#### Binary Content\n\n```\n{\n  \"uri\": \"file:///example.png\",\n  \"mimeType\": \"image/png\",\n  \"blob\": \"base64-encoded-data\"\n}\n```\n\n### Annotations\n\nResources, resource templates and content blocks support optional annotations that provide hints to clients about how to use or display the resource:\n\n*   **`audience`**: An array indicating the intended audience(s) for this resource. Valid values are `\"user\"` and `\"assistant\"`. For example, `[\"user\", \"assistant\"]` indicates content useful for both.\n*   **`priority`**: A number from 0.0 to 1.0 indicating the importance of this resource. A value of 1 means “most important” (effectively required), while 0 means “least important” (entirely optional).\n*   **`lastModified`**: An ISO 8601 formatted timestamp indicating when the resource was last modified (e.g., `\"2025-01-12T15:00:58Z\"`).\n\nExample resource with annotations:\n\n```\n{\n  \"uri\": \"file:///project/README.md\",\n  \"name\": \"README.md\",\n  \"title\": \"Project Documentation\",\n  \"mimeType\": \"text/markdown\",\n  \"annotations\": {\n    \"audience\": [\"user\"],\n    \"priority\": 0.8,\n    \"lastModified\": \"2025-01-12T15:00:58Z\"\n  }\n}\n```\n\nClients can use these annotations to:\n\n*   Filter resources based on their intended audience\n*   Prioritize which resources to include in context\n*   Display modification times or sort by recency\n\nCommon URI Schemes\n------------------\n\nThe protocol defines several standard URI schemes. This list not exhaustive—implementations are always free to use additional, custom URI schemes.\n\n### https://\n\nUsed to represent a resource available on the web.Servers **SHOULD** use this scheme only when the client is able to fetch and load the resource directly from the web on its own—that is, it doesn’t need to read the resource via the MCP server.For other use cases, servers **SHOULD** prefer to use another URI scheme, or define a custom one, even if the server will itself be downloading resource contents over the internet.\n\n### file://\n\nUsed to identify resources that behave like a filesystem. However, the resources do not need to map to an actual physical filesystem.MCP servers **MAY** identify file:// resources with an XDG MIME type, like `inode/directory`, to represent non-regular files (such as directories) that don’t otherwise have a standard MIME type.\n\n### git://\n\nGit version control integration.\n\n### Custom URI Schemes\n\nCustom URI schemes **MUST** be in accordance with RFC3986, taking the above guidance in to account.\n\nError Handling\n--------------\n\nServers **SHOULD** return standard JSON-RPC errors for common failure cases:\n\n*   Resource not found: `-32002`\n*   Internal errors: `-32603`\n\nExample error:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 5,\n  \"error\": {\n    \"code\": -32002,\n    \"message\": \"Resource not found\",\n    \"data\": {\n      \"uri\": \"file:///nonexistent.txt\"\n    }\n  }\n}\n```\n\nSecurity Considerations\n-----------------------\n\n1.   Servers **MUST** validate all resource URIs\n2.   Access controls **SHOULD** be implemented for sensitive resources\n3.   Binary data **MUST** be properly encoded\n4.   Resource permissions **SHOULD** be checked before operations\n\n"},"metadata":{"arguments":"{\"link_id\":9}","display_result":"","duration":"4s","id":"call_AAEXKmmCWD","is_error":false,"mcp_server":{"name":"mcp-server"},"name":"click","result":"【9†Resources†https://modelcontextprotocol.io/specification/2025-06-18/server/resources】\nTitle: Resources - Model Context Protocol\n\nURL Source: https://modelcontextprotocol.io/specification/2025-06-18/server/resources\n\nMarkdown Content:\nThe Model Context Protocol (MCP) provides a standardized way for servers to expose resources to clients. Resources allow servers to share data that provides context to language models, such as files, database schemas, or application-specific information. Each resource is uniquely identified by a URI.\n\nUser Interaction Model\n----------------------\n\nResources in MCP are designed to be **application-driven**, with host applications determining how to incorporate context based on their needs.For example, applications could:\n\n*   Expose resources through UI elements for explicit selection, in a tree or list view\n*   Allow the user to search through and filter available resources\n*   Implement automatic context inclusion, based on heuristics or the AI model’s selection\n\nHowever, implementations are free to expose resources through any interface pattern that suits their needs—the protocol itself does not mandate any specific user interaction model.\n\nCapabilities\n------------\n\nServers that support resources **MUST** declare the `resources` capability:\n\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"subscribe\": true,\n      \"listChanged\": true\n    }\n  }\n}\n```\n\nThe capability supports two optional features:\n\n*   `subscribe`: whether the client can subscribe to be notified of changes to individual resources.\n*   `listChanged`: whether the server will emit notifications when the list of available resources changes.\n\nBoth `subscribe` and `listChanged` are optional—servers can support neither, either, or both:\n\n```\n{\n  \"capabilities\": {\n    \"resources\": {} // Neither feature supported\n  }\n}\n```\n\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"subscribe\": true // Only subscriptions supported\n    }\n  }\n}\n```\n\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"listChanged\": true // Only list change notifications supported\n    }\n  }\n}\n```\n\nProtocol Messages\n-----------------\n\n### Listing Resources\n\nTo discover available resources, clients send a `resources/list` request. This operation supports pagination.**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"resources/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"resources\": [\n      {\n        \"uri\": \"file:///project/src/main.rs\",\n        \"name\": \"main.rs\",\n        \"title\": \"Rust Software Application Main File\",\n        \"description\": \"Primary application entry point\",\n        \"mimeType\": \"text/x-rust\"\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n### Reading Resources\n\nTo retrieve resource contents, clients send a `resources/read` request:**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"resources/read\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"contents\": [\n      {\n        \"uri\": \"file:///project/src/main.rs\",\n        \"mimeType\": \"text/x-rust\",\n        \"text\": \"fn main() {\\n    println!(\\\"Hello world!\\\");\\n}\"\n      }\n    ]\n  }\n}\n```\n\n### Resource Templates\n\nResource templates allow servers to expose parameterized resources using URI templates. Arguments may be auto-completed through the completion API.**Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"method\": \"resources/templates/list\"\n}\n```\n\n**Response:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"result\": {\n    \"resourceTemplates\": [\n      {\n        \"uriTemplate\": \"file:///{path}\",\n        \"name\": \"Project Files\",\n        \"title\": \"📁 Project Files\",\n        \"description\": \"Access files in the project directory\",\n        \"mimeType\": \"application/octet-stream\"\n      }\n    ]\n  }\n}\n```\n\n### List Changed Notification\n\nWhen the list of available resources changes, servers that declared the `listChanged` capability **SHOULD** send a notification:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/resources/list_changed\"\n}\n```\n\n### Subscriptions\n\nThe protocol supports optional subscriptions to resource changes. Clients can subscribe to specific resources and receive notifications when they change:**Subscribe Request:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 4,\n  \"method\": \"resources/subscribe\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\n**Update Notification:**\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/resources/updated\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\nMessage Flow\n------------\n\nData Types\n----------\n\n### Resource\n\nA resource definition includes:\n\n*   `uri`: Unique identifier for the resource\n*   `name`: The name of the resource.\n*   `title`: Optional human-readable name of the resource for display purposes.\n*   `description`: Optional description\n*   `mimeType`: Optional MIME type\n*   `size`: Optional size in bytes\n\n### Resource Contents\n\nResources can contain either text or binary data:\n\n#### Text Content\n\n```\n{\n  \"uri\": \"file:///example.txt\",\n  \"mimeType\": \"text/plain\",\n  \"text\": \"Resource content\"\n}\n```\n\n#### Binary Content\n\n```\n{\n  \"uri\": \"file:///example.png\",\n  \"mimeType\": \"image/png\",\n  \"blob\": \"base64-encoded-data\"\n}\n```\n\n### Annotations\n\nResources, resource templates and content blocks support optional annotations that provide hints to clients about how to use or display the resource:\n\n*   **`audience`**: An array indicating the intended audience(s) for this resource. Valid values are `\"user\"` and `\"assistant\"`. For example, `[\"user\", \"assistant\"]` indicates content useful for both.\n*   **`priority`**: A number from 0.0 to 1.0 indicating the importance of this resource. A value of 1 means “most important” (effectively required), while 0 means “least important” (entirely optional).\n*   **`lastModified`**: An ISO 8601 formatted timestamp indicating when the resource was last modified (e.g., `\"2025-01-12T15:00:58Z\"`).\n\nExample resource with annotations:\n\n```\n{\n  \"uri\": \"file:///project/README.md\",\n  \"name\": \"README.md\",\n  \"title\": \"Project Documentation\",\n  \"mimeType\": \"text/markdown\",\n  \"annotations\": {\n    \"audience\": [\"user\"],\n    \"priority\": 0.8,\n    \"lastModified\": \"2025-01-12T15:00:58Z\"\n  }\n}\n```\n\nClients can use these annotations to:\n\n*   Filter resources based on their intended audience\n*   Prioritize which resources to include in context\n*   Display modification times or sort by recency\n\nCommon URI Schemes\n------------------\n\nThe protocol defines several standard URI schemes. This list not exhaustive—implementations are always free to use additional, custom URI schemes.\n\n### https://\n\nUsed to represent a resource available on the web.Servers **SHOULD** use this scheme only when the client is able to fetch and load the resource directly from the web on its own—that is, it doesn’t need to read the resource via the MCP server.For other use cases, servers **SHOULD** prefer to use another URI scheme, or define a custom one, even if the server will itself be downloading resource contents over the internet.\n\n### file://\n\nUsed to identify resources that behave like a filesystem. However, the resources do not need to map to an actual physical filesystem.MCP servers **MAY** identify file:// resources with an XDG MIME type, like `inode/directory`, to represent non-regular files (such as directories) that don’t otherwise have a standard MIME type.\n\n### git://\n\nGit version control integration.\n\n### Custom URI Schemes\n\nCustom URI schemes **MUST** be in accordance with RFC3986, taking the above guidance in to account.\n\nError Handling\n--------------\n\nServers **SHOULD** return standard JSON-RPC errors for common failure cases:\n\n*   Resource not found: `-32002`\n*   Internal errors: `-32603`\n\nExample error:\n\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 5,\n  \"error\": {\n    \"code\": -32002,\n    \"message\": \"Resource not found\",\n    \"data\": {\n      \"uri\": \"file:///nonexistent.txt\"\n    }\n  }\n}\n```\n\nSecurity Considerations\n-----------------------\n\n1.   Servers **MUST** validate all resource URIs\n2.   Access controls **SHOULD** be implemented for sensitive resources\n3.   Binary data **MUST** be properly encoded\n4.   Resource permissions **SHOULD** be checked before operations\n\n","status":"completed"}},"type":"mcp"}</glm_block>


<details type="reasoning" done="true" duration="99" view="" last_tool_call_name="click">
> MCPのリソースに関する仕様が理解できました。リソースはURIで一意に識別され、クライアントがリソースの内容を読み取ることができます。また、リソースの変更を購読する機能もあります。
> 
> 次に、ZAI（Z,AI）をMCPで使う場合の注意点について考えます。特に、APIキー、レート制限、情報源の記録、再現性についてです。
> 
> ### ZAIをMCPで使う場合の注意点
> 1. **APIキーの管理**:
>    - ZAIのAPIキーは安全に管理する必要があります。MCPサーバーがAPIキーを扱う場合、適切なアクセス制御と暗号化が求められます。
>    - APIキーがログや証跡に含まれないように注意する必要があります。
> 
> 2. **レート制限**:
>    - ZAIのAPIにはレート制限がある可能性があります。MCPサーバーはレート制限を尊重し、必要に応じてリトライロジックを実装する必要があります。
>    - レート制限を超えた場合のエラーハンドリングを適切に行う必要があります。
> 
> 3. **情報源の記録**:
>    - ZAIからの応答は、情報源として記録する必要があります。MCPサーバーは、どのリクエストがどのAIからのものかをログに記録すべきです。
>    - 再現性を確保するため、リクエストと応答のメタデータを保存する必要があります。
> 
> 4. **再現性**:
>    - ZAIからの応答は非決定的である可能性があります。同じリクエストに対して異なる応答を返さないように、必要に応じてシードや温度パラメータを固定する必要があります。
>    - テストやデバッグの際に、再現性を確保するためのメカニズムが必要です。
> 
> 5. **エラーハンドリング**:
>    - ZAIのAPIが一時的に利用できない場合のフォールバックメカニズムを考える必要があります。
>    - エラーが発生した場合のリトライポリシーを明確にする必要があります。
> 
> 6. **セキュリティ**:
>    - ZAIとの通信はHTTPSで行う必要があります。
>    - 敏感なデータをZAIに送信する場合、データプライバシーに配慮する必要があります。
> 
> 次に、MCPサーバー運用で起きやすい事故について考えます。
> 
> ### MCPサーバー運用で起きやすい事故
> 1. **権限過大**:
>    - MCPサーバーが過大な権限で動作し、意図しないリソースにアクセスしたり、危険な操作を実行したりする可能性があります。
>    - 対策: 最小権限の原則を適用し、必要な権限のみを与える。
> 
> 2. **秘密情報漏えい**:
>    - MCPサーバーがAPIキーやパスワードなどの秘密情報をログや応答に含めてしまう可能性があります。
>    - 対策: 秘密情報をログに記録しないようにし、応答に含まれないようにする。
> 
> 3. **ログ/証跡の不備**:
>    - MCPサーバーの動作ログや証跡が不十分な場合、問題発生時に原因を特定できません。
>    - 対策: 詳細なログと証跡を残し、監査を可能にする。
> 
> 4. **外部取得の扱い**:
>    - MCPサーバーが外部から取得したデータの信頼性を検証しない場合、誤った情報をAIに提供する可能性があります。
>    - 対策: 外部データの信頼性を検証し、必要に応じてキャッシュや更新ポリシーを設ける。
> 
> 5. **無限ループや再帰呼び出し**:
>    - MCPサーバーが無限ループに陥ったり、再帰的にツールを呼び出したりする可能性があります。
>    - 対策: 呼び出しの深さや回数を制限し、タイムアウトを設ける。
> 
> 6. **リソースの枯渇**:
>    - MCPサーバーがリソースを過度に消費し、システム全体のパフォーマンスに影響を与える可能性があります。
>    - 対策: リソース使用量を監視し、必要に応じて制限を設ける。
> 
> 7. **バージョン互換性**:
>    - MCPのバージョンが変更された場合、クライアントやサーバーが互換性を失う可能性があります。
>    - 対策: バージョン管理を適切に行い、変更に対応する。
> 
> 以上の情報を基に、影響サマリ、設計追記の提案、運用チェックリスト、参照URL一覧を作成します。
> 
> ### 影響サマリ（設計書に必ず反映すべき変更点トップ7）
> 1. **MCPのセキュリティ原則の組み込み**:
>    - ユーザーの同意と制御、データプライバシー、ツールの安全性、LLMサンプリング制御を設計に反映。
> 
> 2. **OAuth 2.1 + RFC 8707 Compliance**:
>    - MCPの認証がOAuth 2.1とRFC 8707に準拠するように設計。
> 
> 3. **最小権限の原則**:
>    - MCPサーバーやツールが最小限の権限で動作するように設計。
> 
> 4. **秘密情報の保護**:
>    - APIキーやパスワードなどの秘密情報がログや応答に含まれないように対策。
> 
> 5. **詳細なログと証跡**:
>    - MCPサーバーの動作ログと証跡を詳細に記録し、監査を可能にする。
> 
> 6. **外部データの信頼性検証**:
>    - MCPサーバーが外部から取得したデータの信頼性を検証するプロセスを設計。
> 
> 7. **バージョン管理と互換性**:
>    - MCPのバージョン変更に対応できるように、バージョン管理を適切に行う。
> 
> ### 設計追記の提案（章立て＋追記文案）
> #### Part03: AI Pack（Core4/Antigravity/MCP・役割固定・コンテキスト共有）
> ##### 追加セクション: MCPセキュリティコンプライアンス
> ```markdown
> #### R-0304: MCPセキュリティコンプライアンス【MUST】
> 
> ##### User Consent（明示的opt-in）
> - MCPツール使用前にユーザーの明示的同意を取得する
> - 同意記録は evidence/mcp_consent/ に保存する
> 
> ##### Data Privacy Boundary
> - docs/: アクセス許可（ReadOnly）
> - sources/: アクセス禁止（機密情報混入リスク）
> - VAULT/: アクセス禁止（暗号化必須領域）
> 
> ##### Tool Safety Gate
> - 実行前確認フロー: MCPツール実行前にリスク評価を実施
> - 高リスク操作: HumanGate承認必須
> - 中リスク操作: Dry-run + diff確認
> - 低リスク操作: Auto-approve可能
> 
> ##### OAuth 2.1 + RFC 8707 Compliance
> - 認証: OAuth 2.1準拠
> - Resource Indicator: RFC 8707に基づくリソース指定
> ```
> 
> #### Part10: Verify Gate（検証手順・VRループ）
> ##### 追加検証項目: MCPサーバーのセキュリティ検証
> ```markdown
> ### V-1001: MCPサーバーの設定検証
> - 判定条件: MCPサーバーの設定がセキュリティポリシーに準拠しているか
> - 合否: 準拠していない場合FAIL
> - 実行方法: checks/verify_mcp_security.ps1
> - ログ: evidence/verify_reports/YYYYMMDD_HHMMSS_mcp_security.md
> ```
> 
> ### 運用チェックリスト（MCP/外部情報取得/ログ/権限/例外）
> 1. **MCPサーバーの設定**:
>    - [ ] OAuth 2.1 + RFC 8707に準拠した認証設定
>    - [ ] 最小権限の原則を適用
>    - [ ] ツールの安全性が確保されている
> 
> 2. **秘密情報の保護**:
>    - [ ] APIキーやパスワードがログに記録されない
>    - [ ] 応答に秘密情報が含まれない
>    - [ ] 機密情報は暗号化して保管
> 
> 3. **ログと証跡**:
>    - [ ] MCPサーバーの動作ログが詳細に記録される
>    - [ ] 証跡がevidence/に保存される
>    - [ ] ログのローテーションと削除ポリシーが設定されている
> 
> 4. **外部情報取得**:
>    - [ ] 外部データの信頼性が検証される
>    - [ ] キャッシュと更新ポリシーが設けられている
>    - [ ] レート制限とエラーハンドリングが実装されている
> 
> 5. **例外処理**:
>    - [ ] MCPサーバーダウン時のフォールバックメカニズムが実装されている
>    - [ ] 無限ループや再帰呼び出しの防止策が設けられている
>    - [ ] バージョン互換性の問題に対応できる
> 
> ### 参照URL一覧（一次情報中心）
> 1. [Model Context Protocol Specification (2025-11-25)](https://modelcontextprotocol.io/specification/2025-11-25)
> 2. [Model Context Protocol Authorization (draft)](https://modelcontextprotocol.io/specification/draft/basic/authorization)
> 3. [Model Context Protocol Tools (2025-06-18)](https://modelcontextprotocol.io/specification/2025-06-18/server/tools)
> 4. [Model Context Protocol Resources (2025-06-18)](https://modelcontextprotocol.io/specification/2025-06-18/server/resources)
> 5. [Model Context Protocol Architecture (2025-06-18)](https://modelcontextprotocol.io/specification/2025-06-18/architecture)
> 6. [Model Context Protocol Versioning](https://modelcontextprotocol.io/specification/versioning)
> 7. [Model Context Protocol Overview (2025-06-18)](https://modelcontextprotocol.io/specification/2025-06-18/basic)
> 8. [Model Context Protocol Overview (2025-11-25)](https://modelcontextprotocol.io/specification/2025-11-25/basic)
> 
> 以上で、設計に影響する「変わりやすい前提」の確定と、それに基づいた設計書への反映案をまとめました。
</details>

<glm_block view="" tool_call_name="finish">{"data":{"metadata":{"arguments":"{}","display_result":"","duration":"0s","id":"call_HewdjRKec4","is_error":false,"mcp_server":{"name":"mcp-server"},"name":"finish","result":"","status":"completed"}},"type":"mcp"}</glm_block>

# 最終回答

## A. 影響サマリ（設計書に必ず反映すべき変更点トップ7）

1. **MCPセキュリティ原則の組み込み**  
   - 2025-11-25仕様で定められた「User Consent and Control」「Data Privacy」「Tool Safety」「LLM Sampling Controls」をPart03 R-0304に明記し、UI/承認フローを実装する。

2. **OAuth 2.1 + RFC 8707 準拠**  
   - 認証フローはOAuth 2.1とRFC 8707（Resource Indicator）に準拠。クライアント・サーバー間でProtected Resource Metadata・Client ID Metadata Documentを利用。

3. **最小権限の原則**  
   - MCPサーバー／ツール／クライアントごとに必要最小限のスコープのみを要求。Scope選択は`WWW-Authenticate`ヘッダーの`scope`指示を優先。

4. **秘密情報の保護**  
   - APIキー・機密データはVAULTに隔離し、MCPサーバー／クライアントコード・ログに含めない。環境変数・Secret Manager経由で注入。

5. **詳細なログと証跡**  
   - MCPリクエスト／レスポンスを`evidence/mcp_logs/`に永続保存。認可トレース、ツール実行履歴、エラーを記録し、監査可能にする。

6. **外部データの信頼性検証**  
   - 外部MCPサーバー／ツールが返すデータはSSOT（docs/）と照合。キャッシュTTL・ freshnessチェックを実装し、古い情報を利用しない。

7. **バージョン管理と互換性**  
   - MCPバージョンは`YYYY-MM-DD`形式で明示。クライアント・サーバー間のcapabilityネゴシエーションを厳密に行い、後方互換性を担保。

---

## B. 設計追記の提案（章立て＋追記文案）

### Part03: AI Pack（Core4/Antigravity/MCP・役割固定・コンテキスト共有）

#### 5.4 MCPセキュリティコンプライアンス（新規セクション）  
```markdown
#### R-0304: MCPセキュリティコンプライアンス【MUST】

##### User Consent（明示的opt-in）
- MCPツール使用前にユーザーの明示的同意を取得する。
- 同意記録は `evidence/mcp_consent/YYYYMMDD_HHMMSS_<tool>.md` に保存。

##### Data Privacy Boundary
- `docs/`: ReadOnly（MCPリソース読み取りのみ可）。
- `sources/`: アクセス禁止（機密情報混入リスク）。
- `VAULT/`: アクセス禁止（暗号化必須領域）。

##### Tool Safety Gate
- **高リスク操作**（ファイル削除・外部書き込み）: HumanGate承認必須。
- **中リスク操作**（ファイル作成・設定変更）: Dry-run + diff確認。
- **低リスク操作**（読み取り・検索）: Auto-approve可能。

##### OAuth 2.1 + RFC 8707 Compliance
- 認証フローはOAuth 2.1 IETF Draftに準拠。
- Resource IndicatorはRFC 8707に基づき、MCPサーバーの正規URIを指定。
- クライアントはClient ID Metadata Documentをホストし、サーバーはその検証を行う。
```

### Part10: Verify Gate（検証手順・VRループ）

#### 6.6 MCPサーバー検証（新規セクション）  
```markdown
### V-1001: MCPサーバー設定検証
- **判定条件**:
  1. OAuth 2.1 + RFC 8707 準拠の認証設定
  2. 最小権限スコープのみ利用
  3. 秘密情報がログ／レスポンスに含まれない
- **合否**: 1つでも不備があればFAIL
- **実行方法**: `checks/verify_mcp_security.ps1`
- **ログ**: `evidence/verify_reports/YYYYMMDD_HHMMSS_mcp_security.md`

### V-1002: MCPログ・証跡検証
- **判定条件**:
  1. 過去7日間のMCPログが存在
  2. ログにリクエストID・ツール名・入出力・スタンプが記録
  3. エラー時のリトライ／フォールバックが記録
- **合否**: 記録漏れがあればWARN
- **実行方法**: `checks/verify_mcp_logs.ps1`
- **ログ**: `evidence/verify_reports/YYYYMMDD_HHMMSS_mcp_logs.md`
```

---

## C. 運用チェックリスト（MCP/外部情報取得/ログ/権限/例外）

| No. | チェック項目 | 実施内容 | 確認方法 |
|------|-------------|-------------|-----------|
| 1    | OAuth 2.1認証設定 | Protected Resource Metadata・Client ID Metadata Documentを利用 | `verify_mcp_security.ps1` |
| 2    | 最小権限スコープ | WWW-Authenticateヘッダーscope指示を優先 | 同上 |
| 3    | 秘密情報保護 | APIキー等はVAULT／Secret Managerで管理 | ログ／コードレビュー |
| 4    | User Consentフロー | ツール実行前に明示的同意UIを実装 | 手動テスト |
| 5    | MCPログ保存 | リクエスト／レスポンスを7日間保持 | `verify_mcp_logs.ps1` |
| 6    | 外部データ信頼性検証 | キャッシュTTL・freshnessチェックを実装 | 同上 |
| 7    | フォールバック | MCPサーバーダウン時ReadOnlyキャッシュ利用 | 手動切断テスト |
| 8    | 無限ループ防止 | ツール呼び出し深度／回数制限 | 負荷テスト |
| 9    | バージョン互換性 | capabilityネゴシエーション時の互換チェック | `verify_mcp_security.ps1` |
| 10   | 監査対応 | 四半期ごとにMCPログ／設定をレビュー | `quarterly_audit.sh` |

---

## D. 参照URL一覧（一次情報中心）

[1] Specification (2025-11-25). https://modelcontextprotocol.io/specification/2025-11-25.  
[2] Authorization (draft). https://modelcontextprotocol.io/specification/draft/basic/authorization.  
[3] Tools (2025-06-18). https://modelcontextprotocol.io/specification/2025-06-18/server/tools.  
[4] Resources (2025-06-18). https://modelcontextprotocol.io/specification/2025-06-18/server/resources.  
[5] Architecture (2025-06-18). https://modelcontextprotocol.io/specification/2025-06-18/architecture.  
[6] Versioning. https://modelcontextprotocol.io/specification/versioning.  
[7] Overview (2025-06-18). https://modelcontextprotocol.io/specification/2025-06-18/basic.