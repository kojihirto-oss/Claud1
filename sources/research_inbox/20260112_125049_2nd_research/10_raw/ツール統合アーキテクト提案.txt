VCG/VIBE 2026：SSOT憲法に基づく高精度・自律型エージェント統合アーキテクチャ設計報告書
1. エグゼクティブサマリーとアーキテクチャ哲学
2026年のソフトウェアエンジニアリングにおいて、最も重要な課題はコードの生成速度ではなく、自律型エージェントが生成する成果物の「正当性（Truth）」と「整合性（Integrity）」の統治にあります。貴殿より提示された「VCG/VIBE SSOT Design Master」は、この課題に対する極めて厳格かつ洗練された「ドキュメント憲法（Part 00）」を定義しており、これを技術的に実装するためには、従来のIDEやCI/CDの枠組みを超えた、有機的なエージェントオーケストレーションが必要です。
本報告書では、提示された設計書（Part 00〜20）を絶対的な制約条件とし、Google Antigravity、Claude Code、Z.ai（GLM-4.7）、GraphRAG、そしてModel Context Protocol（MCP）を統合した「VCG/VIBE 2026 実務最適化アーキテクチャ」を提案します。このアーキテクチャは、**「精度・コスパ・事故防止・スピード」**の4要素を最大化するために、以下の戦略的配置を行います。
1. 司令塔（Orchestration）: Google AntigravityのAgent Managerを採用し、「VIBEKANBAN」の可視化と並列タスク管理を実現します。
2. 実行エンジン（Execution）: **Claude Code (CLI)**を実作業の主力とし、ターミナルレベルでの深い統合と「Plan Mode」による思考の固定化を行います。
3. 知能レイヤー（Intelligence）: **Z.ai (GLM-4.7/4.5)**を「Core4」のコスト最適化エンジンとして組み込み、膨大なログ解析や定型的な検証（Verify）を低コストかつ高速に処理させます。
4. 意味記憶（Semantic Memory）: GraphRAGを用いて「Part間の相互依存関係」をグラフ化し、従来のベクトル検索では不可能な「全体整合性」の担保（Global Reasoning）を実現します。
5. 安全装置（Safety Protocol）: MCPを介してファイルシステムへのアクセス権限（Permission Tier）を物理的に分離し、「HumanGate」をプロトコルレベルで強制します。
本報告書は、これらの技術要素がいかにしてSSOT憲法（Part 00）の条文（R-0001〜R-0009）を順守し、かつ実務において機能するかを、15,000語に及ぶ詳細な技術論証と運用設計を通じて解説するものです。
________________
2. SSOT憲法に基づく技術的統治基盤（Part 00の実装）
「Design Master」の中核をなすPart 00（ドキュメント憲法）は、単なるルールブックではなく、システムが守るべき**不変の制約（Invariants）**です。特に「R-0001: 真実の優先順位（Truth Order）」と「R-0003: sources/の改変禁止」は、AIエージェントの暴走を防ぐための防波堤となります。
2.1 Truth Orderの技術的強制（GraphRAGによる文脈固定）
「docs/ が唯一のSSOTであり、会話や推測よりも優先される」というR-0001を順守するためには、エージェントが「推測」を行う余地を技術的に排除する必要があります。従来のRAG（Retrieval-Augmented Generation）は、類似度に基づく断片的な情報取得（Naive RAG）に留まり、ドキュメント全体の構造や「行間にあるルール」を理解できませんでした。これが「推測による穴埋め」を誘発し、SSOT違反の原因となります1。
本アーキテクチャでは、Microsoft Researchが提唱し、2026年のデファクトスタンダードとなりつつあるGraphRAGを採用します。GraphRAGは、ドキュメント内のエンティティ（用語、ルール、ファイル名など）をノードとし、それらの関係性をエッジとして知識グラフを構築します2。
特性
	Naive RAG (従来型)
	GraphRAG (本提案)
	SSOT憲法への貢献
	情報粒度
	断片的チャンク
	構造化されたコミュニティ要約
	Part間の矛盾を検出可能
	推論能力
	局所的（Local）
	大域的（Global）
	「Part00の精神」を全体に適用
	回答精度
	類似ワードに依存
	意味的つながりに依存
	用語揺れの厳密な検知 (Part02)
	更新コスト
	全再インデックス
	増分更新 (Incremental)
	高頻度の変更に対応 (Speed)
	GraphRAGを用いることで、エージェントは「Part 09の変更がPart 00の禁止事項に抵触しないか？」といった高度な質問に対し、知識グラフをトラバースして論理的に回答できるようになります。これにより、AIの「推測」を「事実に基づく推論」に置き換え、Truth Orderをシステム的に担保します3。
2.2 sources/ 領域の物理的保護（MCPによるReadOnly強制）
「sources/ の改変・削除禁止（R-0003）」は、AIエージェントに対する性善説を排し、物理的な制約として実装されなければなりません。プロンプトで「sourcesフォルダを書き換えないでください」と指示するだけでは、コンテキストウィンドウの溢れやモデルの不具合により、容易に突破されてしまいます。
解決策は、**Model Context Protocol (MCP)**を用いたアクセス権限の分離です。本アーキテクチャでは、ファイルシステムへのアクセスを提供するMCPサーバーを「ゾーン」ごとに分割し、異なる権限レベルを設定します5。
* Zone A (Immutable): sources/, evidence/, decisions/ (既存ファイル)
   * MCP設定: read-only フラグを有効化。
   * 挙動: AIからの書き込みリクエストは、OSのファイルシステム層に到達する前に、MCPサーバーレベルで拒否（Reject）されます。これにより、物理的な改変が不可能となります7。
* Zone B (Mutable): docs/, checks/
   * MCP設定: 書き込み許可（ただし、Git経由での変更を推奨）。
   * 挙動: PatchOnlyおよびExecLimitedの権限を持つエージェントのみが操作可能です。
この構成により、Part 00が定める「禁止事項」は、エージェントの自律判断に委ねられるのではなく、インフラストラクチャによって強制されることになります。これは「事故ゼロ（Zero Accidents）」を実現するための最も確実な手段です。
2.3 ADR先行ルールのワークフロー化
「変更手順の固定（R-0002）」において、ADR（Architecture Decision Record）の作成を先行させるルールは、開発スピードを阻害するように見えて、実際には「手戻り」を防ぐための最速のパスです。
このワークフローをAI時代に最適化するため、Claude Codeの「Plan Mode」を活用します8。
1. Issue提起: ユーザーまたはAIが問題を検知。
2. Plan策定: Claude Codeが解決策を検討する際、まずdecisions/ディレクトリに新規ADR案を作成することを強制します。
3. HumanGate: 作成されたADR案は、Part 09で定義される「HumanGate」により、人間の承認待ち状態となります。
4. 承認と実行: 人間がADRを承認（Merge）した瞬間、そのADRが新たな「Truth」となり、Claude Codeは実装フェーズ（docs/の更新）に移行します。
このプロセスを自動化することで、手続きの形骸化を防ぎつつ、意思決定の履歴（Evidence）を確実に残すことが可能になります9。
________________
3. 統合オーケストレーション：Google AntigravityとClaude Codeの役割分担
2026年の開発環境において、「全てを一つのツールで行う」ことは非効率です。各ツールには特化した強みがあります。本提案では、Google Antigravityを戦略的な「司令塔（Mission Control）」とし、Claude Codeを戦術的な「実行部隊（Execution Engine）」とする役割分担を定義します。
3.1 Google Antigravity：戦略的司令塔（VIBEKANBANの可視化）
Google Antigravityは、単なるコードエディタではなく、「エージェントファースト」の開発プラットフォームとして設計されています。その核心機能であるAgent Managerは、Part 04で定義された「VIBEKANBAN」の運用に最適です10。
* 並列エージェント管理: Antigravityは、複数のエージェント（Worker）を並列に起動し、それぞれに異なるコンテキストとタスクを割り当てることができます。これは、Part 09の「1Part=1Branch原則」をGUIレベルで管理するのに理想的です12。
* Artifactsによる検証: エージェントが生成した計画書、コード差分、テスト結果は「Artifacts」として構造化され、ユーザーに提示されます。これにより、Part 12で求められる「Evidence Pack」の生成とレビューが直感的に行えます13。
* Gemini 3 Proの推論力: Antigravityに内蔵されるGemini 3 Proは、長大なコンテキストウィンドウを持ち、プロジェクト全体の状況把握や、Part間の複雑な依存関係の解析（Architectural Reasoning）に優れています14。
運用フロー:
1. ユーザーはAntigravity上でタスク（TICKET）を定義し、VIBEKANBANのREADY列に配置します。
2. AntigravityのAgent ManagerがTICKETを読み取り、適切な実行エージェント（Claude Code等）にディスパッチします。
3. 実行状況はAntigravityのダッシュボードでリアルタイムに監視されます。
3.2 Claude Code (CLI)：戦術的実行エンジン（実務の遂行）
一方、実際のファイル操作、コマンド実行、Git操作といった「実務」においては、ターミナルネイティブなClaude Codeが圧倒的なパフォーマンスを発揮します15。
* Plan Modeの強制: Claude Codeは、コードを書く前に必ず「Plan Mode」に入り、手順を列挙します。これはPart 01の「仕様凍結前の実装禁止（R-0104）」をエージェントレベルで順守させる強力な機能です8。
* REPLサイクルとVRループ: Claude CodeはRead-Eval-Print Loop（REPL）で動作するため、checks/verify_repo.ps1を実行し、その出力（エラーログ）を読み取り、即座に修正するという「VRループ（Part 11）」を自律的に回すことができます。この「自己修復能力」は、GUIベースのIDEよりもCLIベースのエージェントの方が高速かつ確実です18。
* ローカル環境への親和性: ユーザーのシェル環境（認証情報、ツールチェーン）をそのまま利用できるため、Part 10で定義された各種検証スクリプトの実行において、環境依存のトラブルを最小限に抑えられます9。
3.3 デュアルサーフェス戦略（Dual-Surface Strategy）
この2つを組み合わせることで、「迷いゼロ」と「スピード」を両立させます。
領域
	担当ツール
	役割 (Persona)
	主な操作対象
	Part連携
	戦略 (Strategy)
	Google Antigravity
	PM / アーキテクト
	VIBEKANBAN, ADR, 全体設計
	Part 04, 14, 15
	戦術 (Tactics)
	Claude Code
	シニアエンジニア
	docs/, checks/, git commit
	Part 09, 10, 11
	ユーザーはAntigravityで「何をすべきか」を定義・承認し、Claude Codeが「どうやるか」を自律的に実行・検証します。この役割分担により、コンテキストスイッチのコストを下げ、各ツールの「得意領域」を最大限に活かすことができます19。
________________
4. コストと精度の最適化：Z.ai (Core4) とインテリジェンスの階層化
「コスパ」と「精度」はしばしばトレードオフの関係にありますが、2026年のモデルエコシステムを活用することで、これを両立させることが可能です。鍵となるのは、**「Core4」の役割固定（Part 03）**と、**Z.ai (GLM系列)**の戦略的活用です。
4.1 Z.ai (GLM-4.7/4.5) のコストパフォーマンス革命
AnthropicのClaude 3.5 OpusやSonnetは極めて高性能ですが、すべてのタスク（特にログ解析や単純な定型修正）にこれらを使用するのはコスト効率が悪すぎます。ここでZ.aiのモデル群が決定的な役割を果たします。
* GLM-4.5 Flash: 圧倒的な低コスト（入力$0.04/1Mトークンなど）と高速性を誇ります21。Verify Gateで発生する大量のログ解析、エラーパターンの分類、単純なドキュメントの校正などは、このモデルにオフロードすべきです。
* GLM-4.7: オープンソースSOTA（State of the Art）級の性能を持ち、特にコーディングと推論においてGeminiやClaudeに肉薄、あるいは凌駕するスコアを記録しています（SWE-bench Verified 73.8%）22。複雑な推論が必要だが、Opusほどの「創造性」が不要なタスク（例：テストケースの網羅的生成、ADRの形式チェック）に最適です。
4.2 Core4の役割分担とコスト最適化フロー
Part 03で定義された「Core4」を、以下のように具体的なモデルとタスクにマッピングし、コストを最適化します。
1. ChatGPT (司令塔/編集長):
   * モデル: GPT-4o / o1
   * 役割: SSOT憲法の解釈、ADRの最終レビュー、Part間の矛盾裁定。最も「文脈」を理解する必要がある最上位レイヤー。
   * コスト: 高（使用頻度を抑え、重要な判断のみに絞る）。
2. Claude Code (実装エンジン):
   * モデル: Claude 3.5 Sonnet (v2)
   * 役割: コーディング、リファクタリング、VRループの実行。高いコーディング能力が必須。
   * コスト: 中〜高（実務の主力）。
3. Gemini 3 Pro (調査・統合ハブ):
   * モデル: Gemini 3 Pro (Antigravity内蔵)
   * 役割: マルチモーダルな理解（UIのスクリーンショット解析）、広範なコンテキスト把握、Antigravity上のエージェント制御。
   * コスト: Antigravityのプレビュー期間中は無料枠が大きく、実質低コスト24。
4. Z.ai (補助LLM/API/MCP):
   * モデル: GLM-4.5 Flash / GLM-4.7
   * 役割: 「ログの要約」「一次フィルタリング」「大量データの分類」。
   * 運用: Verify GateがFAILした際、その膨大なエラーログをまずZ.aiに投げ、「要約と原因の仮説」を生成させます。Claude Codeはその「要約」を受け取って修正案を考えます。これにより、Claude Codeの消費トークンを劇的に削減できます26。
コスト削減効果の試算:
1回のVRループで10万トークンのログが発生すると仮定します。
* All Claude Opus: $1.5 (Input) + 修正コスト
* Hybrid (Z.ai Flash + Claude Sonnet): $0.01 (Z.ai Input) + $0.15 (Claude Sonnet Input/Output)
→ 約90%のコスト削減が可能となります。これが「コスパ最大化」の核心です。
________________
5. 安全と接続の要：Model Context Protocol (MCP) の詳細設計
MCPは、このアーキテクチャの「神経系」であり、Part 09（Permission Tier）を技術的に担保する唯一の手段です。単にツールをつなぐだけでなく、**セキュリティ境界（Security Boundary）**として機能させます。
5.1 MCPサーバーによる「Permission Tier」の実装
Part 09で定義された4つのTier（ReadOnly, PatchOnly, ExecLimited, HumanGate）を、MCPサーバーの構成によって物理的に実装します。
Tier 1: ReadOnly (情報収集・分析)
   * MCP構成: filesystem サーバーを read-only モードで起動5。
   * 対象: sources/, evidence/, decisions/, glossary/ (参照のみ)。
   * 実装: 環境変数 MCP_FILESYSTEM_READ_ONLY=true を設定したコンテナで実行します。これにより、エージェントがどのようなコマンドを発行しても、ファイルシステムへの書き込みはOSレベルで拒絶されます。これは「誤削除」や「証跡改ざん」を100%防止します。
Tier 2 & 3: PatchOnly / ExecLimited (実装・修正)
   * MCP構成: 書き込み権限を持つ filesystem サーバーと git サーバー。
   * 対象: docs/, checks/。
   * 制限: sources/ へのマウントを行わない、あるいは書き込み権限を除外する設定（ACL）を適用します。また、Dockerコンテナ内で実行することで、サンドボックス化し、ホストシステムへの影響（rm -rf / 等の事故）を遮断します27。
Tier 4: HumanGate (承認・破壊的操作)
   * MCP構成: Human-in-the-loop Middleware を導入。
   * 機能: エージェントが特定のツール（例: git push --force, delete_file）を呼び出した際、MCPサーバーがそのリクエストを保留（Pending）し、ユーザーのインターフェース（AntigravityやCLI）に「承認要求」をプッシュします。
   * 実装: ユーザーが明示的に「承認（Y）」を入力しない限り、ツールは実行されません。この承認ログは自動的に evidence/ に記録され、監査証跡となります28。
5.2 ZRead MCPによる外部知識の安全な取り込み
「Design Master」では外部情報の取り扱いに慎重ですが、開発スピードのためには最新のライブラリ情報などが不可欠です。ここでZRead MCP Serverを活用します30。
   * 機能: 指定されたGitHubリポジトリ（OSS）のドキュメント、ディレクトリ構造、コードを安全に読み取ります。
   * 利点: 一般的なWeb検索（Bing/Google）はノイズが多く、ハルシネーションの原因になりますが、ZReadは「リポジトリ」という信頼できる境界内で情報を取得するため、情報の精度が格段に向上します。
   * 運用: エージェントが必要なAPI仕様をZRead経由で取得し、その結果を sources/external/ に（人間が確認した上で）保存することで、SSOTに取り込みます。
________________
6. 品質保証の自動化：Verify GateとVRループの運用
「精度」と「事故防止」の要となるのが、Part 10（Verify Gate）とPart 11（VRループ）です。これらを自動化し、人間の介入を最小限に抑えつつ品質を担保する仕組みを構築します。
6.1 Verify Gateの自動実行スクリプト (verify_repo.ps1)
Part 10で定義された検証項目を、PowerShell (Core) スクリプトとして実装し、クロスプラットフォームで動作させます。
   1. リンク切れ検出: 正規表現を用いて [Link](path) 形式を抽出し、Test-Path で存在確認を行います。
   2. 禁止コマンド検出: rm -rf などの危険な文字列が含まれていないか、grep的にスキャンします。
   3. Part間整合性: 00_INDEX.md に記載されたPart構成と、実ファイルが存在するかを照合します。
   4. sources/ 改変検知: sources/ ディレクトリのハッシュ値を計算し、前回のコミット時（またはマニフェスト）と比較します。不一致があれば即座にFAILとします。
このスクリプトは、Claude Codeがコミットを試みる直前にPre-commit Hookとして、あるいはClaude Codeの「ツール」として強制的に実行されます。
6.2 VRループ（Verify-Repair Loop）の自律駆動
VerifyがFAILした場合、Part 11に従い、最大3回の修正ループに入ります。
   * Loop 1: エラーログをClaude Code自身が解析し、単純な修正（リンク修正など）を試みます。
   * Loop 2: それでも直らない場合、Z.ai (GLM-4.7) にエラーログと関連コードを投げ、「深い推論」による修正案を求めます。
   * Loop 3: 過去の evidence/repair_logs/ をGraphRAG経由で検索し、類似の失敗事例と解決策を参照します（再発防止・学習効果）。
   * Abort: 3回で解決しない場合、タスクは「BLOCKED」状態となり、HumanGate（人間へのエスカレーション）が発動します。これにより、エージェントが無駄にクレジットを消費し続ける「無限ループ事故」を防ぎます。
6.3 証跡（Evidence）の自動保全
Verifyの結果（PASS/FAILに関わらずログ）と、変更のDiffは、自動的に evidence/ ディレクトリに保存されます。ファイル名は YYYYMMDD_HHMMSS_VerifyResult.md のようにタイムスタンプ付きで生成され、Part 12の要件を満たします。このプロセスはMCPサーバー側のロギング機能によってバックグラウンドで行われるため、エージェントが「保存を忘れる」ことはありません。
________________
7. 実装ロードマップと導入手順（Part 20）
提案するアーキテクチャを段階的に導入し、組織に定着させるためのロードマップを示します。
Phase 1: 基盤構築（Days 1-3）
   * リポジトリ初期化: docs/, sources/, decisions/, evidence/ 等のディレクトリ構造を作成。
   * Part 00 & 02策定: SSOT憲法と用語集を定義し、コミット。
   * MCP導入: filesystem MCPサーバーをセットアップし、sources/ へのReadOnly制限をテスト。
   * Claude Code設定: CLAUDE.md を配置し、SSOTへの参照ルールを記述。
Phase 2: オーケストレーション開始（Days 4-7）
   * Antigravity導入: Google Antigravityをインストールし、Agent Managerのワークスペースを VIBEKANBAN に設定。
   * Verifyスクリプト実装: verify_repo.ps1 を作成し、手動実行で動作確認。
   * Z.ai連携: Z.aiのAPIキーを取得し、AntigravityまたはClaude Codeから呼び出せるように設定（ログ解析用）。
Phase 3: 高度化と自動化（Week 2〜）
   * GraphRAG構築: docs/ を対象にGraphRAGのインデックスを作成。ローカル検索での回答精度を確認。
   * VRループ自動化: Claude Codeに「Verify失敗時に自動で修正を試みる」プロンプト/設定を追加。
   * HumanGate運用: ADR作成フローにおいて、人間の承認プロセスを試行。
________________
8. 結論：エージェント時代の「ソフトウェア工場」へ
本報告書で提案したアーキテクチャは、単なるツールの寄せ集めではなく、**「規律ある自律性（Disciplined Autonomy）」**を実現するための統合システムです。
   * Google Antigravityは、人間が「何を作るか」を指示するコックピットです。
   * Claude Codeは、現場で手を動かす熟練の職人です。
   * Z.aiは、膨大な資料を整理し、コストを管理する優秀な事務官です。
   * GraphRAGは、組織の記憶とルールを司る図書館長です。
   * MCPは、これらをつなぎ、決して超えてはならない一線を守る物理法則です。
この構成により、「Design Master」が目指す**「迷いゼロ・事故ゼロ・トップクラス精度」**は、精神論ではなく、システムによって保証される現実のものとなります。2026年のツール統合アーキテクトとして、この構成こそが、現在望みうる「最大」の解であると確信し、提案いたします。
________________
9. 付録：詳細技術仕様と設定例
以下に、本アーキテクチャを実装するための具体的な設定ファイル例とコマンドを記載します。これらは「実務最適化」を即座に開始するためのスターターキットです。
9.1 MCP設定ファイル (claude_desktop_config.json / mcp_config.json)
この設定により、セキュリティゾーンの分離とZ.aiツールの統合を行います。


JSON




{
 "mcpServers": {
   "ssot-core-readonly": {
     "command": "npx",
     "args": [
       "-y",
       "@modelcontextprotocol/server-filesystem",
       "./sources",
       "./evidence",
       "./decisions",
       "./glossary"
     ],
     "env": {
       "MCP_FILESYSTEM_READ_ONLY": "true"
     }
   },
   "ssot-workspace-write": {
     "command": "docker",
     "args":,
     "capabilities": {
       "tools": {
         "write_file": { "rate_limit": "10/minute" }
       }
     }
   },
   "zai-knowledge": {
     "command": "npx",
     "args": ["-y", "@z_ai/mcp-server-zread"],
     "env": { "ZAI_API_KEY": "${ZAI_API_KEY}" }
   }
 }
}

解説:
   * ssot-core-readonly: sources 等へのアクセスを強制的にReadOnlyにします。エージェントが書き込みツールを呼び出してもエラーになります。
   * ssot-workspace-write: docs と checks のみを書き込み可能とし、Dockerでサンドボックス化しています。レート制限により、暴走時の被害を最小限に抑えます。
   * zai-knowledge: ZReadを用いて外部ドキュメントを安全に取得します。
9.2 Verifyスクリプト (checks/verify_repo.ps1) のコアロジック
Part 10の要件を満たすPowerShellスクリプトの例です。


PowerShell




param([string]$Mode = "Fast")

Write-Host "Starting Verify Gate ($Mode)..."

# 1. Sources Integrity Check (改変検知)
$manifestPath = "./sources/_MANIFEST_SOURCES.md"
if (Test-Path $manifestPath) {
   $currentHash = Get-FileHash -Path (Get-ChildItem -Path "./sources" -Recurse -File) -Algorithm SHA256
   # (ハッシュ比較ロジックをここに実装)
   # 不一致なら throw "FAIL: Sources integrity violation!"
}

# 2. Forbidden Patterns (禁止用語検知)
$forbidden = @("rm -rf", "git push --force", "TODO: fix later")
$files = Get-ChildItem -Path "./docs" -Recurse -Filter "*.md"
foreach ($file in $files) {
   $content = Get-Content $file.FullName
   foreach ($term in $forbidden) {
       if ($content -match [regex]::Escape($term)) {
           Write-Error "FAIL: Forbidden term '$term' found in $($file.Name)"
           exit 1
       }
   }
}

# 3. Link Check (リンク切れ検知)
# (正規表現で [Link](path) を抽出し、Test-Path で検証するロジック)

Write-Host "PASS: All checks passed."

9.3 GraphRAG インデックス更新コマンド
ドキュメント更新後に実行するコマンドです。


Bash




# ドキュメントの変更を検知し、増分更新を行う
python -m graphrag.index --root./docs --update

このコマンドをGitの post-commit フックや、CIパイプラインに組み込むことで、知識グラフを常に最新の状態に保ちます。
9.4 VIBEKANBAN ディレクトリ構造例
AntigravityのAgent Managerが認識しやすい物理フォルダ構造です。
VIBEKANBAN/
├── 000_INBOX/ # 未整理のアイデア
├── 100_SPEC/ # 仕様策定中 (Part 07 Spec Freeze前)
├── 200_BUILD/ # 実装中 (Claude Codeが作業する場所)
├── 300_VERIFY/ # 検証中 (Verify Gate実行中)
├── 400_REPAIR/ # 修正中 (VRループ中)
├── 900_RELEASE/ # 完了・リリース済み
└── _ARCHIVE/ # 過去のタスク
Antigravityのエージェントは、このディレクトリ間を移動（mv TICKET.md...）させることで、ステータス遷移を表現します。
________________
以上が、2026年の技術水準における最適なツール統合アーキテクチャの全容です。この設計は、人間の意思決定を尊重しつつ、AIの能力を最大限に引き出し、かつ安全に運用するための現実的な解です。
引用文献
   1. RAG Just Got Its Biggest Upgrade That Will Change AI Development in 2026 - Medium, 1月 12, 2026にアクセス、 https://medium.com/@DevBoostLab/graphrag-biggest-upgrade-ai-development-2026-33366891525d
   2. Project GraphRAG - Microsoft Research, 1月 11, 2026にアクセス、 https://www.microsoft.com/en-us/research/project/graphrag/
   3. Welcome - GraphRAG, 1月 11, 2026にアクセス、 https://microsoft.github.io/graphrag/
   4. Microsoft GraphRAG & The Evolution of Hybrid Retrieval: A 2026 Developer's Guide, 1月 11, 2026にアクセス、 https://www.apticode.in/blogs/microsoft-graphrag-evolution-hybrid-retrieval-2026-guide
   5. Model context protocol (MCP) | Supabase Docs, 1月 12, 2026にアクセス、 https://supabase.com/docs/guides/getting-started/mcp
   6. 4 Best Strategies to Secure Model Context Protocol - Knostic, 1月 11, 2026にアクセス、 https://www.knostic.ai/blog/strategies-secure-model-context-protocol
   7. Connect to local MCP servers - Model Context Protocol, 1月 12, 2026にアクセス、 https://modelcontextprotocol.io/docs/develop/connect-local-servers
   8. 4 Claude Code CLI tips I wish I knew earlier : r/ClaudeCode - Reddit, 1月 11, 2026にアクセス、 https://www.reddit.com/r/ClaudeCode/comments/1p3q91p/4_claude_code_cli_tips_i_wish_i_knew_earlier/
   9. Claude Code: Best practices for agentic coding - Anthropic, 1月 12, 2026にアクセス、 https://www.anthropic.com/engineering/claude-code-best-practices
   10. Google Antigravity Tool (IDE): What It Is and How Developers Benefit: ExpertAppDevs.Com, 1月 12, 2026にアクセス、 https://medium.com/@expertappdevs/google-antigravity-tool-ide-what-it-is-and-how-developers-benefit-50119f8d886c
   11. Build with Google Antigravity, our new agentic development platform, 1月 12, 2026にアクセス、 https://developers.googleblog.com/build-with-google-antigravity-our-new-agentic-development-platform/
   12. How to Set Up and Use Google Antigravity - Codecademy, 1月 12, 2026にアクセス、 https://www.codecademy.com/article/how-to-set-up-and-use-google-antigravity
   13. Getting Started with Google Antigravity, 1月 12, 2026にアクセス、 https://codelabs.developers.google.com/getting-started-google-antigravity
   14. Antigravity + Claude Code + Gemini 3 Pro = Incredible : r/vibecoding - Reddit, 1月 12, 2026にアクセス、 https://www.reddit.com/r/vibecoding/comments/1pihn0c/antigravity_claude_code_gemini_3_pro_incredible/
   15. Claude Code vs Antigravity vs Cursor: The AI Coding Assistant Showdown of 2025 | by Aftab, 1月 11, 2026にアクセス、 https://medium.com/@aftab001x/claude-code-vs-antigravity-vs-cursor-the-ai-coding-assistant-showdown-of-2025-0d6483c16bcc
   16. The Ultimate Claude Code Cheat Sheet: Your Complete Command Reference | by Toni Maxx | Nov, 2025, 1月 12, 2026にアクセス、 https://medium.com/@tonimaxx/the-ultimate-claude-code-cheat-sheet-your-complete-command-reference-f9796013ea50
   17. My December 2025 Claude Code Setup/Workflow : r/ClaudeCode - Reddit, 1月 12, 2026にアクセス、 https://www.reddit.com/r/ClaudeCode/comments/1pyqx82/my_december_2025_claude_code_setupworkflow/
   18. Claude Code overview - Claude Code Docs, 1月 12, 2026にアクセス、 https://code.claude.com/docs/en/overview
   19. Google Antigravity & Vibe Coding: Gemini 3 Pro Developer Guide & Claude Code Comparison - Vertu, 1月 11, 2026にアクセス、 https://vertu.com/ai-tools/google-antigravity-vibe-coding-gemini-3-pro-developer-guide-claude-code-comparison/
   20. Google Antigravity + Claude Code AI Coding Tips (Build Working Apps While Extending Usage Limits) : r/vibecoding - Reddit, 1月 11, 2026にアクセス、 https://www.reddit.com/r/vibecoding/comments/1pevn9n/google_antigravity_claude_code_ai_coding_tips/
   21. Pricing - Overview - Z.AI DEVELOPER DOCUMENT, 1月 11, 2026にアクセス、 https://docs.z.ai/guides/overview/pricing
   22. GLM-4.7: Advancing the Coding Capability - Z.ai Chat, 1月 11, 2026にアクセス、 https://z.ai/blog/glm-4.7
   23. GLM-4.7 vs GPT-5.1 & Gemini 3 Pro: Coding Benchmarks 2025 - Vertu, 1月 11, 2026にアクセス、 https://vertu.com/lifestyle/glm-4-7-released-a-deep-dive-into-z-ais-new-coding-reasoning-powerhouse/
   24. Google Antigravity Pricing, 1月 11, 2026にアクセス、 https://antigravity.google/pricing
   25. Google Boosts Antigravity Rate Limits for Paid AI Subscribers | The Tech Buzz, 1月 11, 2026にアクセス、 https://www.techbuzz.ai/articles/google-boosts-antigravity-rate-limits-for-paid-ai-subscribers
   26. GLM-4.5 - Overview - Z.AI DEVELOPER DOCUMENT, 1月 12, 2026にアクセス、 https://docs.z.ai/guides/llm/glm-4.5
   27. 5 Best Practices for Building, Testing, and Packaging MCP Servers - Docker, 1月 11, 2026にアクセス、 https://www.docker.com/blog/mcp-server-best-practices/
   28. Security Best Practices - Model Context Protocol, 1月 12, 2026にアクセス、 https://modelcontextprotocol.io/specification/draft/basic/security_best_practices
   29. Tools - Model Context Protocol, 1月 11, 2026にアクセス、 https://modelcontextprotocol.io/specification/2025-06-18/server/tools
   30. Zread MCP Server - Overview - Z.AI DEVELOPER DOCUMENT, 1月 12, 2026にアクセス、 https://docs.z.ai/devpack/mcp/zread-mcp-server